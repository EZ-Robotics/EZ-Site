"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7513],{84696:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>u,toc:()=>h});var r=n(85893),o=n(11151),a=n(74866),i=n(85162);const s={slug:"pure-pursuit",title:"Pure Pursuit",authors:["jess"],tags:["vex","software","open-source"]},l=void 0,u={permalink:"/projects/pure-pursuit",source:"@site/projects/2024-02-05-pure-pursuit/index.md",title:"Pure Pursuit",description:"I made a pure-pursuit algorithm for mecanum drive and tank drives.",date:"2024-02-05T00:00:00.000Z",formattedDate:"February 5, 2024",tags:[{label:"vex",permalink:"/projects/tags/vex"},{label:"software",permalink:"/projects/tags/software"},{label:"open-source",permalink:"/projects/tags/open-source"}],readingTime:11.956666666666667,hasTruncateMarker:!0,authors:[{name:"Jess Zarchi",title:"Roboticist",url:"https://roboticsisez.com",imageURL:"https://github.com/Unionjackjz1.png",key:"jess"}],frontMatter:{slug:"pure-pursuit",title:"Pure Pursuit",authors:["jess"],tags:["vex","software","open-source"]},unlisted:!1,prevItem:{title:"DD-3",permalink:"/projects/dd-3"},nextItem:{title:"EZ-Template",permalink:"/projects/about-ez-template"}},c={authorsImageUrls:[void 0]},h=[{value:"Position Tracking",id:"position-tracking",level:2},{value:"Mecanum Drive",id:"mecanum-drive",level:2},{value:"Point to Point",id:"point-to-point",level:3},{value:"Paths with Strafe",id:"paths-with-strafe",level:3},{value:"Point Injection and Path Smoothing",id:"point-injection-and-path-smoothing",level:3},{value:"Final Mecanum",id:"final-mecanum",level:3},{value:"Tank Drive",id:"tank-drive",level:2},{value:"Tracking Differences",id:"tracking-differences",level:3},{value:"Point to Point",id:"point-to-point-1",level:3},{value:"Target Angle",id:"target-angle",level:4},{value:"Overshooting",id:"overshooting",level:4},{value:"Combining Both",id:"combining-both",level:4},{value:"Final Tank",id:"final-tank",level:3}];function d(e){const t={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["I made a ",(0,r.jsx)(t.a,{href:"https://www.mathworks.com/help/nav/ug/pure-pursuit-controller.html",children:"pure-pursuit"})," algorithm for ",(0,r.jsx)(t.a,{href:"https://github.com/EZ-Robotics/EZ-Mecanum",children:"mecanum drive"})," and ",(0,r.jsx)(t.a,{href:"https://github.com/EZ-Robotics/EZ-Tank-Odom",children:"tank drives"}),"."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:n(15516).Z+"",width:"579",height:"189"})}),"\n",(0,r.jsx)(t.p,{children:"Pure Pursuit is a tracking algorithm that allows a robot to follow a given path by following a point some distance ahead like a carrot on a stick.  It requires some way of knowing where your current position is and a generated path."}),"\n",(0,r.jsx)(t.h2,{id:"position-tracking",children:"Position Tracking"}),"\n",(0,r.jsx)(t.p,{children:"Position tracking is a piece of code that given 2 or 3 encoders you can extrapolate the X, Y, and angle of the robot."}),"\n",(0,r.jsxs)(t.p,{children:["This is explained far better by others, and here are the resources that I used:",(0,r.jsx)(t.br,{}),"\n",(0,r.jsx)(t.a,{href:"https://wiki.purduesigbots.com/software/odometry",children:"5225A Tracking Documentation"}),(0,r.jsx)(t.br,{}),"\n",(0,r.jsx)(t.a,{href:"https://www.youtube.com/watch?v=_T6KHywSP58",children:"QUEEN Video Explanation"})]}),"\n",(0,r.jsx)(t.p,{children:"This code relies on the speed at which sensors update, because it figures out the change in position over the time it takes for sensors to update, and adds that change to a current global value."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"LEFT_OFFSET"})," and ",(0,r.jsx)(t.code,{children:"RIGHT_OFFSET"}),' are the "track width".  This is the width between the tracking wheels on the robot,  I have them split into 2 variables because technically they do not need to be the same number.',(0,r.jsx)(t.br,{}),"\n",(0,r.jsx)(t.code,{children:"CENTER_OFFSET"})," is the distance from a perpendicular tracking wheel to the turning center of the robot.  This number can be anything, but the nicest way is for this to align with the robot's turning center.  This can be tuned by turning the robot in place and adjusting this number until the XY stops rotating around the robot."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"void tracking_task() {\r\n  double l_current = 0, r_current = 0;\r\n  double c_current = 0;\r\n  double l = 0, r = 0, c = 0;  // delta distance\r\n  double l_last = 0, r_last = 0, c_last = 0;\r\n  double radius_r = 0, radius_c = 0, h = 0, h2 = 0;  // rad for big circle\r\n  double beta = 0, alpha = 0, theta = 0;\r\n  double Xx = 0, Yy = 0, Xy = 0, Yx = 0;\r\n  while (true) {\r\n    l_current = get_raw_left();\r\n    r_current = get_raw_right();\r\n    c_current = get_raw_center();\r\n\r\n    l = l_current - l_last;\r\n    r = r_current - r_last;\r\n    c = c_current - c_last;\r\n\r\n    l_last = l_current;\r\n    r_last = r_current;\r\n    c_last = c_current;\r\n\r\n    double width = LEFT_OFFSET + RIGHT_OFFSET;\r\n\r\n    // diff between wheels for correcting turning\r\n    theta = (l - r) / width;\r\n\r\n    if (theta != 0) {\r\n      radius_r = r / theta;\r\n      beta = theta / 2.0;\r\n      h = ((radius_r + RIGHT_OFFSET) * sin(beta)) * 2.0;\r\n      radius_c = c / theta;\r\n      h2 = (radius_c + CENTER_OFFSET) * 2.0 * sin(beta);\r\n    } else {\r\n      h = l;\r\n      h2 = 0;\r\n      beta = 0;\r\n    }\r\n\r\n    alpha = angle_rad + beta;\r\n\r\n    Xx = h2 * cos(alpha);\r\n    Xy = h2 * -sin(alpha);\r\n    Yx = h * sin(alpha);\r\n    Yy = h * cos(alpha);\r\n\r\n    current.x += (Xx + Yx) / TICK_PER_INCH;\r\n    current.y += (Xy + Yy) / TICK_PER_INCH;\r\n    angle_rad += theta;\r\n    current.theta = to_deg(angle_rad);\r\n\r\n    pros::delay(1);\r\n  }\r\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"mecanum-drive",children:"Mecanum Drive"}),"\n",(0,r.jsxs)(t.p,{children:["Mecanum wheels allow the robot to move forward / backward and side to side.  These wheels get their own section here because they are effectively a cheat code for getting this code to work.  Because they can strafe, any error that's accumulated along the way can be accounted for.  With a drivetrain that cannot strafe, if you aren't following the path as exactly as you can, it becomes extremely difficult to account for it later.  This is why I chose this drive first, it allows me to go through all of this code without the problems that a typical drivetrain would give me.\r\n",(0,r.jsx)(t.img,{src:n(36858).Z+"",width:"657",height:"380"})]}),"\n",(0,r.jsx)(t.h3,{id:"point-to-point",children:"Point to Point"}),"\n",(0,r.jsx)(t.p,{children:"To get the robot to move to a new target point, I need to calculate the amount the robot needs to move in the X direction, the amount the robot needs to move in the Y direction, and the amount the robot needs to move in turn."}),"\n",(0,r.jsx)(t.p,{children:"The direction the robot moves will change depending on the desired end angle. Some trigonometry is done to figure out the relative directions the robot needs to go, as while the robot turns the motor powers will all change."}),"\n",(0,r.jsx)(t.p,{children:"The final thing to do is scale everything down.  If X output and Y output both exceed the maximum power that can be sent to the motors, even if one is magnitudes larger than the other, the robot will end up going straight.  We solve this by scaling everything down to a larger number."}),"\n",(0,r.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/ZbMDKJ0zA3o?si=T7nrteA03m6vQWDE",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"void point_to_point() {\r\n  // Compute PID\r\n  xPID.compute(current.x);\r\n  yPID.compute(current.y);\r\n  aPID.compute(get_angle());\r\n\r\n  // Vector math\r\n  double angle = to_rad(get_angle());\r\n  double raw_x_power = (xPID.output * cos(angle)) - (yPID.output * sin(angle));\r\n  double raw_y_power = (yPID.output * cos(angle)) + (xPID.output * sin(angle));\r\n  double raw_a_power = aPID.output;\r\n\r\n  // Set output powers\r\n  int x_output = raw_x_power;\r\n  int y_output = raw_y_power;\r\n  int a_output = clip_num(raw_a_power, 60, -60);\r\n  int max_xy = 110;\r\n\r\n  // Vector scaling \r\n  if (fabs(raw_x_power) > max_xy || fabs(raw_y_power) > max_xy) {\r\n    if (fabs(raw_x_power) > fabs(raw_y_power)) {\r\n      double scale = max_xy / fabs(raw_x_power);\r\n      x_output = clip_num(raw_x_power, max_xy, -max_xy);\r\n      y_output = raw_y_power * scale;\r\n    } else {\r\n      double scale = max_xy / fabs(raw_y_power);\r\n      x_output = raw_x_power * scale;\r\n      y_output = clip_num(raw_y_power, max_xy, -max_xy);\r\n    }\r\n  } else {\r\n    x_output = raw_x_power;\r\n    y_output = raw_y_power;\r\n  }\r\n\r\n  // Set motors\r\n  raw_set_drive(x_output, y_output, a_output);\r\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Mecanum drives that use the VRC wheels are slower when strafing than in forward / backward.  Because of this, I knew I'd want a mode where the robot would go straight for most of the motion and then turn at the end to face the desired angle."}),"\n",(0,r.jsx)(t.p,{children:"This piece of code was added to the above function.  It modifies the target angle depending on how far away the robot is from the target position.  If it's more than 12\" away, the robot will go faster and face the target position.  Once the robot is within 12\" of the target it'll start to rotate to the desired angle."}),"\n",(0,r.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/pIiadWcYlac?si=JW_q3pCaxF9RjtR2",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"  // Add for direction\r\n  int add = dir == REV ? 180 : 0;\r\n\r\n  // Set angle target\r\n  double a_target;\r\n  if (fast_move) {\r\n    if (fabs(distance_to_point(target.x, target.y)) < 12) {\r\n      only_look_at_point = false;\r\n      a_target = target.theta;\r\n    } else {\r\n      only_look_at_point = true;\r\n    }\r\n  } else {\r\n    a_target = target.theta;\r\n  }\r\n\r\n  if (only_look_at_point) {\r\n    a_target = absolute_angle_to_point(target.x, target.y) + add;\r\n  }\r\n\r\n  // Compute angle PID and find the shortest path to the angle\r\n  aPID.set_target(relative_angle_to_point(a_target));\r\n  aPID.compute(0);\n"})}),"\n",(0,r.jsx)(t.h3,{id:"paths-with-strafe",children:"Paths with Strafe"}),"\n",(0,r.jsx)(t.p,{children:"The paths the robot will follow will be points the user inputs.  In the example below, the robot will start at (0, 0), travel to (0, 24), then to (24, 24), then back to (0, 0)."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"void autonomous() {\r\n  pure_pursuit(\r\n        {{{0, 24, 0}, FAST_MOVE_FWD},\r\n         {{24, 24, 0}, FAST_MOVE_FWD},\r\n         {{0, 0, 0}, FAST_MOVE_REV}});\r\n  wait_drive();\r\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Once I have a list of points, to decide which point to go to next I see how far away the robot is from the next point.  The target position gets shifted until we're looking at a point that is a distance away from the robot, and it keeps changing until we're at the final position in the list."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"void pure_pursuit() {\r\n  raw_move_odom(movements[pp_index]);\r\n\r\n  if (fabs(distance_to_point(movements[pp_index].target.x, movements[pp_index].target.y)) < 5) {\r\n    pp_index++;\r\n    if (pp_index >= movements.size()) {\r\n      pp_index = movements.size() - 1;\r\n    }\r\n  }\r\n\r\n  point_to_point();\r\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:['I cleaned up how the "turn type" is handled.  There are now 3 turn types:',(0,r.jsx)(t.br,{}),"\n",(0,r.jsx)(t.code,{children:"FAST_MOVE"}),' where the robot faces the target position and within 12" will move to the final angle\r\n',(0,r.jsx)(t.code,{children:"LOOK_AT_TARGET"})," where the robot doesn't care about the end angle, and will always look at the target\r\n",(0,r.jsx)(t.code,{children:"HOLD_ANGLE"})," where the robot will just hold its angle"]}),"\n",(0,r.jsxs)(t.p,{children:["I had to add ",(0,r.jsx)(t.code,{children:"LOOK_AT_TARGET"})," because the distance away from the current target was less than 12\", and the robot would always hold an angle even if I didn't want it to.  This lets me use ",(0,r.jsx)(t.code,{children:"FAST_MOVE"})," as intended, and have all of my injected points follow ",(0,r.jsx)(t.code,{children:"LOOK_AT_TARGET"}),"."]}),"\n",(0,r.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/aUpCYLBIhE0?si=LELL8e9J1XWCjrY3",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"  // Add for direction\r\n  int add = current_turn_type == FAST_MOVE_REV || LOOK_AT_TARGET_REV ? 180 : 0;\r\n\r\n  // Set angle target\r\n  switch (current_turn_type) {\r\n    // Looks at the target until final distance then goes to the final angle\r\n    case FAST_MOVE_FWD:\r\n    case FAST_MOVE_REV:\r\n      if (fabs(distance_to_point(target, current)) < TURN_FAST_MOVE) {\r\n        a_target = target.theta;\r\n      } else {\r\n        a_target = absolute_angle_to_point(target, current) + add;\r\n      }\r\n      break;\r\n    // Looks at target the entire motion\r\n    case LOOK_AT_TARGET_FWD:\r\n    case LOOK_AT_TARGET_REV:\r\n      if (fabs(distance_to_point(target, current)) > STOP_UPDATING_ANGLE) {\r\n        a_target = absolute_angle_to_point(target, current) + add;\r\n      }\r\n      break;\r\n    // Holds angle the entire motion\r\n    case HOLD_ANGLE:\r\n      a_target = target.theta;\r\n    default:\r\n      break;\r\n  }\n"})}),"\n",(0,r.jsx)(t.h3,{id:"point-injection-and-path-smoothing",children:"Point Injection and Path Smoothing"}),"\n",(0,r.jsxs)(t.p,{children:["This is based on the ",(0,r.jsx)(t.a,{href:"https://www.chiefdelphi.com/t/paper-implementation-of-the-adaptive-pure-pursuit-controller/166552",children:"Dawgma Adaptive Pure Pursuit paper"}),"."]}),"\n",(0,r.jsx)(t.p,{children:'Using the path following above, I want the code to internally add points every 1" along the path.  This will make the robot care about how it gets somewhere instead of blindly aiming towards a single point.  This code creates a new point that\'s 1" away from the current point on the way to the next big target point, and repeats for every input point.'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"// Inject point based on https://www.chiefdelphi.com/t/paper-implementation-of-the-adaptive-pure-pursuit-controller/166552\r\nstd::vector<odom> inject_points(std::vector<odom> imovements) {\r\n  injected_pp_index.clear();\r\n  // Create new vector that includes the starting point\r\n  std::vector<odom> input = imovements;\r\n  input.insert(input.begin(), {{{target.x, target.x, imovements[0].target.theta}, imovements[0].turn_type, imovements[0].max_xy_speed, imovements[0].max_turn_speed}});\r\n\r\n  std::vector<odom> output;  // Output vector\r\n  int output_index = -1;     // Keeps track of current index\r\n\r\n  // This for loop runs for how many points there are minus one because there is one less vector than points\r\n  for (int i = 0; i < input.size() - 1; i++) {\r\n    // Figure out how many points fit in the vector\r\n    int num_of_points_that_fit = (distance_to_point(input[i + 1].target, input[i].target)) / SPACING;\r\n\r\n    // Add parent point\r\n    // Make sure the robot is looking at next point\r\n    output.push_back({input[i].target,\r\n                      input[i + 1].turn_type,\r\n                      input[i].max_xy_speed,\r\n                      input[i].max_turn_speed});\r\n    output_index++;\r\n    injected_pp_index.push_back(output_index);\r\n\r\n    // Add the injected points\r\n    for (int j = 0; j < num_of_points_that_fit; j++) {\r\n      // Calculate the new point with known information: hypot and angle\r\n      double angle_to_point = absolute_angle_to_point(input[i + 1].target, input[i].target);\r\n      pose new_point = vector_off_point(SPACING, {output[output_index].target.x, output[output_index].target.y, angle_to_point});\r\n\r\n      // Make sure the robot is looking at the next point\r\n      turn_types turn;\r\n      if ((input[i + 1].turn_type == FAST_MOVE_REV || input[i + 1].turn_type == FAST_MOVE_FWD) && fabs(distance_to_point(input[i + 1].target, new_point)) > TURN_FAST_MOVE - LOOK_AHEAD) {\r\n        turn = input[i + 1].turn_type == FAST_MOVE_REV ? LOOK_AT_TARGET_REV : LOOK_AT_TARGET_FWD;\r\n      } else {\r\n        turn = input[i + 1].turn_type;\r\n      }\r\n\r\n      // Push new point to vector\r\n      output.push_back({{new_point.x, new_point.y, input[i + 1].target.theta},\r\n                        turn,\r\n                        input[i + 1].max_xy_speed,\r\n                        input[i + 1].max_turn_speed});\r\n      output_index++;\r\n    }\r\n    // Make sure the final point is there\r\n    output.push_back(input[i + 1]);\r\n    output_index++;\r\n  }\r\n\r\n  // Return final vector\r\n  return output;\r\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Another benefit of injecting points is we get more ability to smooth the path.  The Dawgma paper cites another paper by ",(0,r.jsx)(t.a,{href:"https://medium.com/@jaems33/understanding-robot-motion-path-smoothing-5970c8363bc4",children:"James Teow on path smoothing for robots"}),".  I translated his code from Python to C++ and got the below code.  A slight path smoothing helps get rid of impossible sharp corners and gives the robot a path that more closely represents what it's going to follow anyway."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"// Path smoothing based on https://medium.com/@jaems33/understanding-robot-motion-path-smoothing-5970c8363bc4\r\nstd::vector<odom> smooth_path(std::vector<odom> ipath, double weight_smooth, double weight_data, double tolerance) {\r\n  double path[500][2];\r\n  double new_path[500][2];\r\n\r\n  // Convert odom to array\r\n  for (int i = 0; i < ipath.size(); i++) {\r\n    path[i][0] = new_path[i][0] = ipath[i].target.x;\r\n    path[i][1] = new_path[i][1] = ipath[i].target.y;\r\n  }\r\n\r\n  double change = tolerance;\r\n\r\n  while (change >= tolerance) {\r\n    change = 0.0;\r\n    for (int i = 1; i < ipath.size() - 2; i++) {\r\n      for (int j = 0; j < 2; j++) {\r\n        double x_i = path[i][j];\r\n        double y_i = new_path[i][j];\r\n        double y_prev = new_path[i - 1][j];\r\n        double y_next = new_path[i + 1][j];\r\n\r\n        double y_i_saved = y_i;\r\n        y_i += weight_data * (x_i - y_i) + weight_smooth * (y_next + y_prev - (2.0 * y_i));\r\n        new_path[i][j] = y_i;\r\n\r\n        change += abs(y_i - y_i_saved);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Convert array to odom\r\n  std::vector<odom> output = ipath;  // Set output to input so target angles, turn types, and speed hold\r\n  // Overwrite x and y\r\n  for (int i = 0; i < ipath.size(); i++) {\r\n    output[i].target.x = new_path[i][0];\r\n    output[i].target.y = new_path[i][1];\r\n  }\r\n\r\n  return output;\r\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"final-mecanum",children:"Final Mecanum"}),"\n",(0,r.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/pVcdgffsMnA?si=P3Cc8XRpN6KGd6hI",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,r.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/A_Q_yBHhWSY?si=9qDZo20ImXHNNA5K",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,r.jsx)(t.h2,{id:"tank-drive",children:"Tank Drive"}),"\n",(0,r.jsxs)(t.p,{children:["Now the goal is to get this all working properly on a tank drive setup.  I have a kind of working version ",(0,r.jsx)(t.a,{href:"https://github.com/EZ-Robotics/peewee",children:"here"})," but I didn't have a lot of time with that robot to iron everything out."]}),"\n",(0,r.jsxs)(t.p,{children:["Below is my rewrite of this about a year later.  This uses v3.0.0 of ",(0,r.jsx)(t.a,{href:"https://ez-robotics.github.io/EZ-Template/",children:"EZ-Template"})," as a base."]}),"\n",(0,r.jsx)(t.h3,{id:"tracking-differences",children:"Tracking Differences"}),"\n",(0,r.jsx)(t.p,{children:'For the tank drives, I wanted to play with using no tracking wheels.  Tracking wheels are free-spinning wheels that have sensors on them, and they are mounted on "suspension" so they always contact the ground even if the robot lifts off the ground.'}),"\n",(0,r.jsx)(t.p,{children:"The encoders inside of V5 motors have been shockingly good, I've had very consistent results using them.  Not having tracking wheels means my robot will not be able to correct for movements that the robot doesn't read.  So I won't be able to push the robot and have it fully correct.  This will only be able to correct for movements the robot thinks have happened, so if there's a wheel slip the robot won't be able to account for that either.  These are all problems that exist with the consistent autonomous routines that have been made previously with the built-in encoders, so for this, I felt it was fine."}),"\n",(0,r.jsx)(t.h3,{id:"point-to-point-1",children:"Point to Point"}),"\n",(0,r.jsx)(t.h4,{id:"target-angle",children:"Target Angle"}),"\n",(0,r.jsx)(t.p,{children:"An issue that isn't had with the mecanum drive is accounting for the target heading because this drive cannot drive.  If we set the target angle to be the angle between our current position and target, we run into problems where the angle doesn't scale with distance.  If we're at (0.5, 11.5) trying to go to (12, 12) the robot will turn 45 degrees to move this half-inch.  As the robot moves this issue will be compounded causing oscillation in the target."}),"\n",(0,r.jsx)(t.p,{children:"This can be solved by projecting a new point (only used for this angle calculation) that follows the line between the robot and the real target.  There are two possible solutions for this though, because we can project forward or backward.  So in this function below, I figure out both of these solutions and pick the one farther away from where the robot targets."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"// Find the angle to face during movements\r\nstd::vector<pose> Drive::find_point_to_face(pose current, pose target, bool set_global) {\r\n  double tx_cx = target.x - current.x;\r\n  double m = 0.0;\r\n  double angle = 0.0;\r\n  if (tx_cx != 0) {\r\n    m = (target.y - current.y) / tx_cx;\r\n    angle = 90.0 - util::to_deg(atan(m));\r\n  }\r\n  pose ptf1 = util::vector_off_point(LOOK_AHEAD, {target.x, target.y, angle});\r\n  pose ptf2 = util::vector_off_point(LOOK_AHEAD, {target.x, target.y, angle + 180});\r\n\r\n  if (set_global) {\r\n    double ptf1_dist = util::distance_to_point(ptf1, current);\r\n    double ptf2_dist = util::distance_to_point(ptf2, current);\r\n    if (ptf1_dist > ptf2_dist) {\r\n      ptf1_running = true;\r\n    } else {\r\n      ptf1_running = false;\r\n    }\r\n  }\r\n  point_to_face = {ptf1, ptf2};\r\n\r\n  return {ptf1, ptf2};\r\n}\n"})}),"\n",(0,r.jsx)(t.h4,{id:"overshooting",children:"Overshooting"}),"\n",(0,r.jsx)(t.p,{children:"The biggest issue (and difference) with implementing this on a tank drive vs a mecanum drive is how overshooting is handed."}),"\n",(0,r.jsxs)(t.p,{children:["With the mecanum code, all of the math is done based on ",(0,r.jsx)(t.code,{children:"target x - current x"}),".  This gives a direction, as it would return positive or negative depending on what the value of each one is."]}),"\n",(0,r.jsx)(t.p,{children:"With the tank code, you have to set your XY PID to the distance between the robot and the target.  The distance formula can give this to us, but it removes any negative values.  In practice, this means the robot will slow down as it approaches the target, but once it passes the target the robot will continue to move."}),"\n",(0,r.jsxs)(a.Z,{groupId:"ex1",defaultValue:"v2",values:[{label:"Tank",value:"v2"},{label:"Mecanum",value:"v3"}],children:[(0,r.jsx)(i.Z,{value:"v2",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"// Compute angle PID and find the shortest path to the angle\r\naPID.set_target(relative_angle_to_point(a_target));\r\naPID.compute(0);\r\n\r\n// Compute xy PID\r\nxyPID.set_target(distance_to_point(temp_xy_target, current) * dir);\r\nxyPID.compute(0);\r\n\r\n// Raw outputs\r\ndouble xy_raw_output = xyPID.output * cos(to_rad(relative_angle_to_point(a_target))); // Scale this based on how far away our angle is to target\r\ndouble a_raw_output = aPID.output;\n"})})}),(0,r.jsx)(i.Z,{value:"v3",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"double angle = to_rad(get_angle());\r\ndouble raw_x_power = (xPID.output * cos(angle)) - (yPID.output * sin(angle));\r\ndouble raw_y_power = (yPID.output * cos(angle)) + (xPID.output * sin(angle));\r\ndouble raw_a_power = aPID.output;\n"})})})]}),"\n",(0,r.jsx)(t.p,{children:"I attempted this last year with cross-product.  This would work if we were at (0, 0) going to (0, 24), but would not work going from (0, 24) to (0, 0), as all of the values flip and it leaves us in the same situation."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"// Check to see if we've passed target\r\npose b = vector_off_point(24, {movements.back().target.x, movements.back().target.y, a_target + 90});\r\npose a = vector_off_point(24, {movements.back().target.x, movements.back().target.y, a_target - 90});\r\npose c = current;\r\nint there = sgn(((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)));  // cross product to decide if above/below line\r\n\r\nif (there == 1)\r\n  passed_target = current_turn_type == FWD ? true : false;\r\nelse if (there == -1)\r\n  passed_target = current_turn_type == REV ? true : false;\n"})}),"\n",(0,r.jsx)(t.p,{children:"The problem that I kept running into was needing a line perpendicular to the robot to decide when the robot was past the target.  This works sometimes if that line ends up being the X or Y axis, but on weird angles this becomes tricky."}),"\n",(0,r.jsx)(t.p,{children:"My solution was to make that line always be the X-axis.  I translate and rotate the target point so the robot is in positive Y always coming down to (0, 0)."}),"\n",(0,r.jsx)(t.p,{children:"For example, if I'm currently at (0, 0) trying to go to (12, 12), the function below will simulate my target being (0, 0) and the robot currently being at (0, 16.9).  Now instead of using the distance formula to decide how far we are, we can just return the Y-axis of our new simulated current position."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"// Returns a distance that the robot is away from the target, but this keeps sign.\r\ndouble Drive::is_past_target(pose target, pose current) {\r\n  // Translated current x, y translated around origin\r\n  double fakek_y = (current.y - target.y);\r\n  double fakek_x = (current.x - target.x);\r\n\r\n  // Angle to face translated around origin\r\n  pose ptf;\r\n  ptf.y = point_to_face[!ptf1_running].y - target.y;\r\n  ptf.x = point_to_face[!ptf1_running].x - target.x;\r\n  int add = current_turn_type == REV ? 180 : 0;\r\n  double fake_angle = util::to_rad((util::absolute_angle_to_point(ptf, {fakek_x, fakek_y})) + add);\r\n\r\n  // Rotate around the origin\r\n  double fake_x = (fakek_x * cos(fake_angle)) - (fakek_y * sin(fake_angle));\r\n  double fake_y = (fakek_y * cos(fake_angle)) + (fakek_x * sin(fake_angle));\r\n\r\n  return fake_y;\r\n}\n"})}),"\n",(0,r.jsx)(t.h4,{id:"combining-both",children:"Combining Both"}),"\n",(0,r.jsx)(t.p,{children:"Those were the two big problems I was fighting to get this code to work.  I'm sure some optimizations can be done (when are there not), but all of this seems to be stable."}),"\n",(0,r.jsx)(t.p,{children:"The iteration for this is similar to the mecanum drive, just using all of the new math talked about above."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"// Odom To Point Task\r\nvoid Drive::ptp_task() {\r\n  // Compute angle\r\n  int add = current_turn_type == REV ? 180 : 0;                                                       // Decide if going fwd or rev\r\n  double a_target = util::absolute_angle_to_point(point_to_face[!ptf1_running], odom_current) + add;  // Calculate the point for angle to face\r\n  aPID.target_set(util::wrap_angle(a_target - drive_imu_get()));                                      // Constrain error to -180 to 180\r\n  aPID.compute(0);\r\n\r\n  // Decide if we've passed the target or not\r\n  int dir = (current_turn_type == REV ? -1 : 1);                                                          // If we're going backwards, add a -1\r\n  int flipped = util::sgn(is_past_target(odom_target, odom_current)) != util::sgn(past_target) ? -1 : 1;  // Check if we've flipped directions to what we started\r\n\r\n  // Compute xy PID\r\n  double temp_target = fabs(is_past_target(odom_target, odom_current));  // Use this instead of distance formula to fix impossible movements\r\n  xyPID.target_set(temp_target * dir * flipped);\r\n  xyPID.compute(0);\r\n\r\n  // Prioritize turning by scaling xy_out down\r\n  double cos_scale = cos(util::to_rad(aPID.target_get()));\r\n  double xy_out = xyPID.output * cos_scale;\r\n\r\n  // Raw outputs\r\n  double l_out = xy_out + aPID.output;\r\n  double r_out = xy_out - aPID.output;\r\n\r\n  // Compute slew\r\n  slew_left.iterate(drive_sensor_left());\r\n  slew_right.iterate(drive_sensor_right());\r\n\r\n  // Vector scaling so nothing can be larger than max speed\r\n  double max_slew_out = fmin(slew_left.output(), slew_right.output());\r\n  // When left and right slew are disabled, scale max speed by the turn scaler so the robot goes slower in curves\r\n  if (fabs(l_out) > max_slew_out || fabs(r_out) > max_slew_out) {\r\n    if (fabs(l_out) > fabs(r_out)) {\r\n      r_out = r_out * (max_slew_out / fabs(l_out));\r\n      l_out = util::clamp(l_out, max_slew_out, -max_slew_out);\r\n    } else {\r\n      l_out = l_out * (max_slew_out / fabs(r_out));\r\n      r_out = util::clamp(r_out, max_slew_out, -max_slew_out);\r\n    }\r\n  }\r\n\r\n  // Set motors\r\n  if (drive_toggle)\r\n    private_drive_set(l_out, r_out);\r\n\r\n  // This is for wait_until\r\n  leftPID.compute(drive_sensor_left());\r\n  rightPID.compute(drive_sensor_right());\r\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"final-tank",children:"Final Tank"}),"\n",(0,r.jsx)(t.p,{children:"I implemented point injection and path smoothing from the mecanum code and this was able to follow paths now."}),"\n",(0,r.jsx)(t.p,{children:'My PID tuning for this is questionable, but the robot is successfully following all of the paths I\'ve given it.  Future improvements would be to implement more "awareness" for turning vs driving, and there was discussion about making the lookahead point variable based on how far away the angles target is too (increase for straight movements, shorten for turns).  This could be fun to play with in the future, but for now, this project is complete for me.'}),"\n",(0,r.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/AY-8lzsPBVA?si=MYc5QOHDj7xkOo3s",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,r.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/BQ13qwDPhdI?si=D4GbmNuB0uyazOHW",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0})]})}function p(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},85162:(e,t,n)=>{n.d(t,{Z:()=>i});n(67294);var r=n(36905);const o={tabItem:"tabItem_Ymn6"};var a=n(85893);function i(e){let{children:t,hidden:n,className:i}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,r.Z)(o.tabItem,i),hidden:n,children:t})}},74866:(e,t,n)=>{n.d(t,{Z:()=>v});var r=n(67294),o=n(36905),a=n(12466),i=n(16550),s=n(20469),l=n(91980),u=n(67392),c=n(50012);function h(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function d(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??function(e){return h(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:o}}=e;return{value:t,label:n,attributes:r,default:o}}))}(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function g(e){let{queryString:t=!1,groupId:n}=e;const o=(0,i.k6)(),a=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(a),(0,r.useCallback)((e=>{if(!a)return;const t=new URLSearchParams(o.location.search);t.set(a,e),o.replace({...o.location,search:t.toString()})}),[a,o])]}function m(e){const{defaultValue:t,queryString:n=!1,groupId:o}=e,a=d(e),[i,l]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:a}))),[u,h]=g({queryString:n,groupId:o}),[m,b]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[o,a]=(0,c.Nk)(n);return[o,(0,r.useCallback)((e=>{n&&a.set(e)}),[n,a])]}({groupId:o}),f=(()=>{const e=u??m;return p({value:e,tabValues:a})?e:null})();(0,s.Z)((()=>{f&&l(f)}),[f]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);l(e),h(e),b(e)}),[h,b,a]),tabValues:a}}var b=n(72389);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var w=n(85893);function _(e){let{className:t,block:n,selectedValue:r,selectValue:i,tabValues:s}=e;const l=[],{blockElementScrollPositionUntilNextRender:u}=(0,a.o5)(),c=e=>{const t=e.currentTarget,n=l.indexOf(t),o=s[n].value;o!==r&&(u(t),i(o))},h=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,w.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":n},t),children:s.map((e=>{let{value:t,label:n,attributes:a}=e;return(0,w.jsx)("li",{role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,ref:e=>l.push(e),onKeyDown:h,onClick:c,...a,className:(0,o.Z)("tabs__item",f.tabItem,a?.className,{"tabs__item--active":r===t}),children:n??t},t)}))})}function x(e){let{lazy:t,children:n,selectedValue:o}=e;const a=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=a.find((e=>e.props.value===o));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return(0,w.jsx)("div",{className:"margin-top--md",children:a.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==o})))})}function y(e){const t=m(e);return(0,w.jsxs)("div",{className:(0,o.Z)("tabs-container",f.tabList),children:[(0,w.jsx)(_,{...e,...t}),(0,w.jsx)(x,{...e,...t})]})}function v(e){const t=(0,b.Z)();return(0,w.jsx)(y,{...e,children:h(e.children)},String(t))}},15516:(e,t,n)=>{n.d(t,{Z:()=>r});const r="data:image/png;base64,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"},36858:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/mecan_cad-051d209ab1e1b8c6de2fb6419b043693.png"},11151:(e,t,n)=>{n.d(t,{Z:()=>s,a:()=>i});var r=n(67294);const o={},a=r.createContext(o);function i(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);