"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5088],{20857:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"dd-3","metadata":{"permalink":"/projects/dd-3","source":"@site/projects/2024-2-24-dd-3/index.md","title":"DD-3","description":"DD-3 is a Star Wars inspired fully functional droid. Built with personality in mind, DD-3 uses automation to give servos life and make DD-3 into a convincing character.","date":"2024-02-24T00:00:00.000Z","formattedDate":"February 24, 2024","tags":[{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"software","permalink":"/projects/tags/software"},{"label":"cad","permalink":"/projects/tags/cad"},{"label":"electrical","permalink":"/projects/tags/electrical"},{"label":"star wars","permalink":"/projects/tags/star-wars"},{"label":"wip","permalink":"/projects/tags/wip"}],"readingTime":21.803333333333335,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"dd-3","title":"DD-3","authors":["jess"],"tags":["hardware","software","cad","electrical","star wars","wip"]},"unlisted":false,"nextItem":{"title":"Pure Pursuit","permalink":"/projects/pure-pursuit"}},"content":"DD-3 is a Star Wars inspired fully functional droid. Built with personality in mind, DD-3 uses automation to give servos life and make DD-3 into a convincing character. \\r\\n\\r\\nBuild log, from the start.  Click `Read More`!\\r\\n\\r\\n![](./banner.jpg)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n---\\r\\n## D-O \\r\\nAfter rewatching Star Wars, I thought D-O was adorable and wanted to make my own.  I\'ve seen the community people who make Star Wars robots before and I\'ve considered building an R2-D2 previously so this isn\'t a new idea.  \\r\\n\\r\\n### Design\\r\\nI found this video series by Matt Denton that showcases him designing, assembling, and troubleshooting D-O.  To me, the interesting part of this project would be designing the parts, software, and aesthetics.  I\'m not bothered if my result ends up looking just like D-O or not.  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/zplirkxl6iM?si=CmTjpj-HwYrTr-gj\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\nMatt has larger 3D printers than I have, I have a Prusa Mini which has a 7\\" bed.  So I\'m restricted to the wheel being 7\\" in diameter. \\r\\n\\r\\nThe big design challenge with this robot is the linkages that go across the entire body.  I liked the idea of having a large hollow center shaft that has axels running across to stabilize it, and the drive shaft is wide enough to have 2 axels running across.  The problem with this is finding a bearing large enough.\\r\\n![](d-o/first_cad.png)\\r\\n\\r\\nI found a ball bearing with 85mm OD, but after putting it in CAD it\'s clear how massive and heavy this bearing will be.  The pink pieces hold bushings that will hold the axles that run across the robot to power the head. \\r\\n![](d-o/first_cad_with_ball_bearing.png)\\r\\n\\r\\nFinally, I found [this](https://www.mcmaster.com/6656K227/) ball bearing which has the same ID but a much more sane OD. \\r\\n\\r\\nI added a ring gear to the wheel and the placement for the powered gear.  This will go 260rpm on a 7\\" wheel, with 1806 2300kv brushless motor on 4s with a 19:1 gearbox from Robot Matter. I also found a 7\\" square o-ring that I can use as a tire.  \\r\\n![](d-o/wheels_tires_gears.png)\\r\\n\\r\\nPlaying with aesthetics, I liked the way an inverted center tire looked instead of the squishy tire that Matt Denton used. \\r\\n![](d-o/inverted_center_tire.png)\\r\\n![](d-o/chassis_no_wheels.png)\\r\\n\\r\\nA cantilevered mechanism like the head on D-O felt wrong to me, so I wanted to design it to be not cantilevered.  I made some geometry for the linkage and copied it to both sides.  I also angled the linkages in because it looked way too wide when it was straight up. I\'m doing the linkage the same way it\'s done on D-O, where one is a crankshaft and one directly powers the linkage, to give control over tilt and height.\\r\\n![](d-o/head_linkage.png)\\r\\n![](d-o/angle.png)\\r\\n\\r\\nThe linkages need a way to be powered and that would have to happen between the wheels.  I placed a servo in the CAD here and it looks like it\'ll fit nicely. \\r\\n![](d-o/servo_in_body.png)\\r\\n\\r\\nThere isn\'t nice geometry to mount something off of, so I figured the best shot I\'d have is to wrap around the center shaft and the support for it.  \\r\\n![](d-o/ms_paint_servo_mount.png)\\r\\n![](d-o/servo_mount_cad_real.png)\\r\\n![](d-o/servo_mount_cad_clear_poly.png)\\r\\n\\r\\nTo get the aluminum rods to spin, my first idea was to use a portion of a gear.  I very quickly stopped liking this idea because of how much material needs to get cut out of the main drive shaft.\\r\\n![](d-o/gear_open.png)\\r\\n![](d-o/gear_closed.png)\\r\\n\\r\\nI played with a linkage instead and was very happy with the amount of material I\'d have to remove. \\r\\n![](d-o/linkage_open.png)\\r\\n![](d-o/linkage_closed.png)\\r\\n\\r\\nI designed the linkage for real and made the piece that clamps onto the aluminum rod.  The hole that needs to be drilled is only 1/2\\".\\r\\n![](d-o/linkage_real_open.png)\\r\\n![](d-o/linkage_real_closed.png)\\r\\n\\r\\nFiguring out how to fit batteries was weirdly challenging.  I knew they needed to go to the bottom because this robot needed to self-balance.  In this image, the 3 rectangles are batteries.  I\'d have to find batteries that fit in the pocketing of the wheel. \\r\\n![](d-o/batteries1.png)\\r\\n\\r\\nI also have to figure out a way to fit the batteries inside of the chassis.  What I came up with was to cut out a chunk of the chassis, and have another printed piece that slides into it.  This makes the main chassis significantly easier to print and lets me iterate battery holder geometry separate from the chassis. \\r\\n![](d-o/hole_in_chassis.png)\\r\\n![](d-o/battery_compartment_in_chassis.png)\\r\\n\\r\\nI fit a pca9685 servo board, a teensy, and an x8r receiver inside. \\r\\n![](d-o/electronics_and_hardware.png)\\r\\n\\r\\n### Assembly\\r\\nI ordered everything I needed and the McMaster order came in first along with the Amazon order.  I have everything I need to get started now except for the drive motors.  I want to wait to print the main chassis until I get the drive motors in so I can do some tolerance tests on them before wasting a bunch of filament.\\r\\n![](d-o/parts.jpg)\\r\\n\\r\\nI thought there was a chance the 45mm ID bearing would fit nicely over the 1.75\\" OD polycarbonate tube I\'m using, but they had a very noticeable amount of slop.  I\'ll have to put aluminum tape over the shaft to fix this. \\r\\n![](d-o/bearing_slop.jpg)\\r\\n\\r\\n6 months later, the motors came in!  I do my tolerance tests on the motor and I\'m able to quickly get things printed.  The battery holder fits nicely in the chassis. \\r\\n![](d-o/first_chassis.jpg)\\r\\n![](d-o/chassis_and_wheels.jpg)\\r\\n\\r\\nI wired the battery to the ESC and plugged it into the x8r and got the motors to spin.  At this point, I realized how overkill my motors are for the size of this setup...\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/VCpQBMrnqF8?si=_AMB_sxgBq27oif1\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>  \\r\\n\\r\\nI hooked everything up to the receiver with no code running just to drive it around and see how it felt to drive.  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/VZo2JVg1lBQ?si=7DwsGdgTZDLhcfuS\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\nThe shaft isn\'t attached properly in those tests, so I need to drill holes in the tube to get everything mounted. \\r\\n![](d-o/jig_for_drilling.jpg)\\r\\n\\r\\nI used the holes I just drilled to index another jig.\\r\\n![](d-o/jig2.jpg)\\r\\n\\r\\nMounting the shaft to the body was simple, and the servos could now be screwed in too. \\r\\n![](d-o/shaft_in_body.jpg)\\r\\n![](d-o/servos_in_body.jpg)\\r\\n\\r\\nI got the outputs from the x8r hooked into the teensy and I pulled my PID class I made for EZ-Template.  I found a library to interpret the mpu6050 and got some PID running to make sure I could get it running.\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/M39WKuFIYLQ?si=QsvU4toI6oTNccvN\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\nChanging the battery with the old holder required taking the wheel off which was incredibly annoying.  I realized I could make the fake wheel removable and insert wheels along the front of the robot instead of the side.  I started making a new battery holder out of some 1/16\\" polycarbonate I had. \\r\\n![](d-o/new_battery_mount.jpg)\\r\\n![](d-o/finished_battery_holder.jpg)\\r\\n\\r\\nI won\'t show the picture here, but after I started testing PID on the robot fully assembled, the robot wouldn\'t turn off and in my attempt to turn it off my finger got caught in the gear.  It ate a good chunk of skin off of my finger.  I decided to take a little break before coming back to it, and need to think of some safeties to make sure something like that never happens again.\\r\\n\\r\\n---  \\r\\n## Open Sauce 2023\\r\\nI didn\'t work on this project for ~3 weeks after it ate my finger.  The next time I was running it, I needed to implement safeties to stop something like that from happening.\\r\\n\\r\\nAt Open Sauce I saw some self-balancing robots that used the same mpu6050 that I was trying to balance with which gave me more confidence that I could pull off what I was trying to pull off.  \\r\\n\\r\\nI also ran into the R2 Builders booth and discussed it with [CuriousMarc](https://www.curiousmarc.com/home).  I remember watching his YouTube videos back in ~2016, it was very cool to meet him.  He let me look inside the droid and we spoke for a bit.  He told me to start simple before jumping into a larger project like an R2. I realized then I had to simplify this project to get it done and making the entire project rely on something I wasn\'t 100% sure would work as well as I hoped was concerning. \\r\\n![](opensauce2023/marc.jpg)\\r\\n\\r\\nI started looking into drawings of droids and stumbled across this which feels so perfect.  It has the D-O tire but adds arms, and the body looks like an R2 but the head is a BB-8.  It seems perfect, and this became my reference photo for simplifying the project.\\r\\n![](opensauce2023/dd3_sketch.png)\\r\\n\\r\\n---\\r\\n## Long Beach Comic Con 2023\\r\\nGoal: September 2-3, 2023\\r\\n\\r\\n### Plans\\r\\nI saw there was a convention on September 2 and 3 and decided to sign up.  This would be my deadline for getting the robot functional.  I\'d like to recreate the image the best I can. \\r\\n\\r\\nA big requirement is for this robot to have personality.  Nothing matches the personality of WALL-E, but I\'d like to do as much as I can to give this personality.  Something great about Chopper is the head tilt.  It adds so many characters and it is something I\'ll be implementing in this robot. \\r\\n\\r\\nThe electronics plan is to use a Teensy 3.2 in the body and the head and communicate over serial between the two.\\r\\n\\r\\n### Design and Assembly\\r\\nThe first thing I needed to do was check the dimensions.  I can\'t easily modify the width of the robot, so I need to make sure the width of the body looks about correct. I took some construction paper to see how I felt about it, and the dimensions I liked were the same as the scaled dimensions from the reference image.  Moving forward I\'ll just grab dimensions from the reference image. \\r\\n![](lbcomicon2023/paper_body.jpg)\\r\\n\\r\\nThe main challenge with this is figuring out how to have a structure above the wheels that gets covered by the body.  I decided to build a T inside the robot where the edges of the T will sit above the wheel.  I replaced the servo mounts with a shoe-horn-like piece that has a 1/2\\" aluminum angle gets mounted to. \\r\\n![](lbcomicon2023/printed_structure.jpg)\\r\\n![](lbcomicon2023/structure_with_alu.jpg)\\r\\n\\r\\nThe legs needed to get mounted diagonally and needed a mount at the end of this T structure.  How this piece is designed changes how the T exactly gets made so I decided to design this first.  This has captive nuts and sits inside of the 1/2\\" angle.  I also needed to make sure there was space at the corners for the body to sit, which distances the length of the arms on the T.\\r\\n![](lbcomicon2023/leg_mount.png)\\r\\n![](lbcomicon2023/leg_mount_in_body.png)\\r\\n\\r\\nThrough this, I also realized that any decorative cover that goes over the wheel is affected by this.  There is a limit to the thickness of it based on the leg mount shown above because there is a slight overhang on the leg mount to the wheel.  I made a test wheel cap to make sure clearance is all good. \\r\\n![](lbcomicon2023/first_wheel_cap.png)\\r\\n\\r\\nI got a little too into it and ended up designing a wheel cap more and I printed it to see it.  This will become the first part I play with finishing and making it look like it\'s not 3D printed. \\r\\n![](lbcomicon2023/first_printed_wheel_cap.jpg)\\r\\n\\r\\nI got both servo mounts replaced with the new horseshoe pieces and got all 4 pieces of angle on.  I have screws going through in multiple axes and have standoffs going between everything to make sure it stays square. \\r\\n![](lbcomicon2023/4_posts.jpg)\\r\\n\\r\\nBecause of the orientation of the angle, I had to flip the leg mounts upside down to what I originally wanted.  When comparing how the new dimensions lined up with the reference image, it all looked the same.  So this was ok and I left it. \\r\\n![](lbcomicon2023/tee.jpg)\\r\\n\\r\\nWorking on this with 1 wheel became increasingly annoying as more weight was added higher up.  I would need legs on this if I wanted to easily continue work on it, so I needed to figure out how the legs were going to be made.  I sanity-checked the angle of the legs and this feels correct. \\r\\n![](lbcomicon2023/leg_feel_check.jpg)\\r\\n\\r\\nThe legs are 1/2\\" aluminum c-channel that I cut out the center of to have the wheel sit.  This wheel is temporary as I come up with a better aesthetically fitting design, but works for testing functionality and stopping this from falling over.\\r\\n![](lbcomicon2023/first_leg_assem.jpg)\\r\\n\\r\\nI was on/off sanding and painting the wheel hubs.  I very quickly learned how important and annoying sanding is.  I ended up with something that I felt was good, and I\'d be doing this much more throughout this project and would get better at this.\\r\\n![](lbcomicon2023/early_sanding_wheel.jpg)\\r\\n![](lbcomicon2023/later_sanding_wheel.jpg)\\r\\n\\r\\nThe wheel hub caps have holes for 4-40 screws to thread into, but the wheels do not have holes for this.  I printed a jig so I could drill these holes out in the wheel, I didn\'t feel like this was worth reprinting the entire wheel for. \\r\\n![](lbcomicon2023/hub_jig.jpg)\\r\\n![](lbcomicon2023/wheel_and_hub.jpg)\\r\\n\\r\\nAn issue on D-O was the gear being press-fitted onto the motor shaft eventually stripped.  I found aluminum hubs on Amazon and decided to make a gear to interface with this. I needed to drill a hole in the body so the set screw was accessible.\\r\\n![](lbcomicon2023/metal_hub.jpg)\\r\\n![](lbcomicon2023/through_hole_for_set_screw.jpg)\\r\\n\\r\\nThe metal hub was a little larger than the smallest point on my gear so I used my \\"lathe\\" (drill + belt sander) to make it smaller.  I checked the diameter frequently with calipers. \\r\\n![](lbcomicon2023/lathe_hub.jpg)\\r\\n![](lbcomicon2023/metal_hub_on_gear.jpg)\\r\\n![](lbcomicon2023/gear_meshing_with_wheel.jpg)\\r\\n\\r\\nThank you to Zach Pinkerton for leaving this review on this [lazy susan](https://a.co/d/1QRSCqb)!  I have no idea if this is the best one or not, but the review is enough for me.\\r\\n![](lbcomicon2023/lazy_susan_review.png)\\r\\n\\r\\nI printed mounts for the lazy susan with space for bushings, and printed brackets to hold a screw that the entire lazy susan pivots off of.  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/M7PbQq6D48E?si=YfEPyxlpbQgVRYaE\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>  \\r\\n  \\r\\nI made a mount for the servo and cut out a linkage from 1/8\\" polycarbonate to connect the servo horn to the lazy susan.  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/Oa7mW7nhXUE?si=9-WQb64j8WYOxDbx\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>  \\r\\n\\r\\nTo make the head spin I designed a ring gear similar to how the wheels work.  I\'ll use an N20 motor to make the head spin. \\r\\n![](lbcomicon2023/ring_gear.jpg)\\r\\n\\r\\nI designed a press-fit mount for the motor that has a set screw to hold the motor in place.  This mounts to the part of the lazy susan that is stationary.\\r\\n![](lbcomicon2023/head_spin_motor_mount.png)  \\r\\n![](lbcomicon2023/motor_mount_printed.jpg)\\r\\n\\r\\nI didn\'t want to buy more aluminum hubs and I feel the head won\'t be under an intense amount of force, so I\'ve come up with a strange solution.  Using a VEX shaft collar with a 1/4\\" screw, I can make geometry in the gear to fit around this.  Then I can clamp the shaft collar to the motor and the gear will clamp around the shaft collar.  This is surprisingly stable, and I imagine this will only work in small scale very low-torque situations like this. \\r\\n![](lbcomicon2023/gear_with_shaft_collar.png)\\r\\n![](lbcomicon2023/spin_gear_almost_mounted.jpg)  \\r\\n![](lbcomicon2023/spin_gear_mounted.jpg)\\r\\n\\r\\nI (finally) switched out the painter\'s tape for \\"adhesive shim\\" aka aluminum tape. The bearings now press fit over the shafts. \\r\\n![](lbcomicon2023/aluminum_tape.jpg)\\r\\n\\r\\nI tried to assemble the robot and realized that I cannot assemble the wheels with the hub caps, they block where screws need to go to keep the wheel from falling off the shaft.  I split the design into 2 parts and have the inner part mounted with magnets.  This also makes it significantly easier to get the color split between the two parts. \\r\\n![](lbcomicon2023/possible_wheel_hub_caps.jpg)\\r\\n![](lbcomicon2023/black_and_green_hub_caps.jpg)\\r\\n\\r\\nI made this test body to check how the dimensions felt on the actual robot, and I wasn\'t happy with it.  I felt like everything needed to come down farther.  \\r\\n![](lbcomicon2023/first_body.jpg)\\r\\n![](lbcomicon2023/first_body_annotated.jpg)\\r\\n\\r\\nSomething I did get right on this design is the lip underneath the body.  This allows me to figure out what to put there, and it doesn\'t limit me mechanically to anything while I continue to work on this. \\r\\n![](lbcomicon2023/under_body_cad.png)\\r\\n\\r\\nI added these new dimensions and added pockets for vents and a decorative front plate.  The dimensions for this ended up feeling perfect.  \\r\\n![](lbcomicon2023/new_body_cad.png)\\r\\n![](lbcomicon2023/new_body.jpg)\\r\\n\\r\\nI tried a new wheel design using a VEX flex wheel but I\'m really not happy with it, instead, I\'ll try using an o-ring. \\r\\n![](lbcomicon2023/3inch_wheel_test.jpg)\\r\\n\\r\\nI designed a new wheel that I think looks better and uses an o-ring instead of a VEX flex wheel.  I also made the leg design, but this won\'t be the final version.  My Prusa Mini is small and I cannot fit this entire leg on the printer.  I\'ll need to split it up into multiple pieces.  Designing each part of this leg from scratch while trying to figure out how to get it all to fit seems like a nightmare.  So instead I\'ve designed the leg as a single part, and once I\'m happy with it I\'ll pull the dimensions for the separated pieces. \\r\\n![](lbcomicon2023/test_leg_front.png)\\r\\n![](lbcomicon2023/test_leg_back.png)\\r\\n\\r\\nI wasn\'t too happy with the back of the leg, I felt it needed more of the hook shape around the wheel.  Once I added that I was pretty happy with the way it looked. \\r\\n![](lbcomicon2023/test_leg_back_annotated.png)\\r\\n![](lbcomicon2023/test_leg_back_real.png)\\r\\n\\r\\nI wanted some mechanical interlocking between the pieces on the leg, so I have these chamfers that make sure these two parts are indexed together. \\r\\n![](lbcomicon2023/interlocking_geometry.png)\\r\\n\\r\\nAll of the parts come together like this.  I changed the shape of the top portion of the leg because more space was needed to cover the keps nuts that hold the metal in place. \\r\\n![](lbcomicon2023/final_leg_uncolored_front.png)\\r\\n![](lbcomicon2023/final_leg_uncolored_back.png)\\r\\n\\r\\nI decided to have separate parts that are painted a different color that attaches to the leg.  \\r\\n![](lbcomicon2023/final_leg_colored.png)\\r\\n\\r\\nThe electronics need covering.  I had the idea to make a piece that flexes around the body and clicks into place over the main printed chassis.  This part is printed and ideally will flex around the chassis.\\r\\n![](lbcomicon2023/center_tire_cad.png)\\r\\n\\r\\nThe center tire idea worked!  The legs are also all coming together and working as I expected. \\r\\n![](lbcomicon2023/robot_center_tire_legs.jpg)\\r\\n![](lbcomicon2023/leg_side.jpg)\\r\\n\\r\\nFor the head, I want it to be mounted with magnets.  For that, I need the head to index with the lazy susan.  I made 3D printed cones to mount to the lazy susan, and have the receiving ends of that on a plate that the head will get mounted to. \\r\\n<iframe width=\\"315\\" height=\\"560\\" src=\\"https://www.youtube.com/embed/GL3CSzSX-kg?si=yHeT-2k5VA5J-A22\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>  \\r\\n\\r\\nI started painting the legs while I designed and worked on the head.  The head is a $0.50 bowl that I got from Target.  I wasn\'t sure if it would work or not, but the dimensions looked about right so I picked it up.  I liked the dimensions so I went ahead with using it.  I also kind of liked the idea of using this wall greens medicine cap as the eye.\\r\\n![](lbcomicon2023/head_and_leg_paint.jpg)\\r\\n\\r\\nI CADed the bowl and added some decoration around it.  I have the eye around a ball joint I\'m going to 3D print and a cover around the eye.  I also made \\"eyebrows\\" that are going to move in and out to give the robot more expression.  I tried adding a top part that is colored, but the robot looks like it has a receding hairline, so I won\'t be going forward with that. \\r\\n![](lbcomicon2023/receding_hairline.png)\\r\\n\\r\\nThe eyebrows are connected to a linkage to move them in and out slightly, and the eye has an X and Y servo that will move it in both axes.\\r\\n![](lbcomicon2023/haed_mechanics.jpg)\\r\\n![](lbcomicon2023/head_unpainted.jpg)\\r\\n\\r\\nTo fill the crevice in the bottom of the bowl, I used durhams putty.  This is a very cheap powder, which is ~$3, and the powder gets added to water.  I can control the viscosity of it by changing the ratio of powder to water, and then I can fill in the area with this.  It\'s very sandable, and does cure to be \\"rock hard\\". \\r\\n![](lbcomicon2023/durhams.jpg)\\r\\n\\r\\nI got the head primed and painted and got the rest of the structure painted. \\r\\n![](lbcomicon2023/head_painted.jpg)\\r\\n![](lbcomicon2023/head_on_robot.jpg)\\r\\n\\r\\nI finished painting the robot and the robot looks good!\\r\\n![](lbcomicon2023/completed_robot.jpg)\\r\\n\\r\\n### Electronics \\r\\nTo get serial, power, and ground to the head I\'m going to use a slip ring.  The slip ring is mounted in the center of the stationary part of the lazy susan. \\r\\n![](lbcomicon2023/slip_ring.jpg)  \\r\\n\\r\\nI wired everything up and started to get the head to work!  I\'m communicating with serial to the Teensy in the head and I\'m able to control all of the servos in the head. \\r\\n<iframe width=\\"315\\" height=\\"560\\"\\r\\nsrc=\\"https://youtube.com/embed/myDEqXWcs1M?si=WTrMGEtHHyj75Lg0\\"\\r\\ntitle=\\"YouTube video player\\"\\r\\nframeborder=\\"0\\"\\r\\nallow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\"\\r\\nallowfullscreen></iframe>\\r\\n\\r\\nEventually after testing some more, the robot stopped responding to anything.  I figured out that I fried the Teensy in the head and the body.  After asking Kiana Dumdumaya why this would happen, we looked through the specs of the Teensy and saw that it only supports 3.3v IO when I\'m using 5v IO and downstepping a 4s lipo to 5v for the electronics.  We decided to switch over to an Arduino Nano Every.  I tried to get that working before the event but for some reason, I ended up frying the Arduino in the body too when I was testing.  I didn\'t want to rush this and waste a bunch of money, so I decided to wait until I could work with Kiana to get all of the electronics working and redo everything with her.  I\'d go to the convention with a completed visual robot and incomplete electronics. \\r\\n\\r\\n### At Long Beach Comic Con 2023\\r\\nI learned an absolute ton at this event.  I felt bad showing up with a robot that didn\'t work, but the amount of support and advice I received to get this robot working was significantly more than I had anticipated.  I was so focused on talking to everyone that I didn\'t take as many pictures as I would have liked. \\r\\n![](lbcomicon2023/r2_roxy.jpg)\\r\\n![](lbcomicon2023/little_dude.jpg)\\r\\n![](lbcomicon2023/group_robot.jpg)\\r\\n![](lbcomicon2023/roxy_max.jpg)\\r\\n\\r\\n---  \\r\\n## OC Maker Faire 2023\\r\\nGoal: October 21, 2023 \\r\\n### Plans\\r\\nWith everything I learned talking to the other droid builders at Long Beach Comic Con, I decided to sand back paint on every part and redo them. The highest priority for me was to go to the next con with the robot working.  Here\'s my priority list:\\r\\n- redoing the wiring, double check everything, adding speakers\\r\\n- repaint everything\\r\\n- practice traveling with the robot to make sure it works after travel\\r\\n\\r\\n### Redoing Wiring\\r\\nI was pretty tired of breaking things and had help from Kiana Dumdumaya to make sure everything was being done correctly. \\r\\n\\r\\nThe first thing she did was make a Google Sheet with every component and connections between them, which I think is genius and super simple. \\r\\n![](ocmakerfair2023/droid_wiring.png)\\r\\n\\r\\nKiana was much more methodical about testing everything than I had been.  I would look up how to connect a component and immediately solder it together, and test as I went.  Kiana made sure everything worked through a breadboard before making any connections and soldering after.  This process made me realize that my frustration with electronics is just my lack of methodology as I have with software and hardware.\\r\\n![](ocmakerfair2023/breadboard.jpg)\\r\\n\\r\\nAn improvement we wanted to make to the wiring was to use SBUS instead of PWM on the receiver.  The receiver has 8 PWM pins, using them means we only have 8 channels from the transmitter to read and 8 pins on the Arduino get used.  SBUS is a serial protocol that can contain all of the channels on the transmitter and would only take UART on the Arduino.  \\r\\n![](ocmakerfair2023/frsky_receiver.png)\\r\\n\\r\\nThis required making a serial inverter so the Arduino could read it, but after that, everything worked seamlessly with an [sbus library](https://github.com/bolderflight/sbus).  We found [this page](https://www.ernstc.dk/arduino/sbus.html) which had a schematic for a serial inverter for SBUS.\\r\\n![](ocmakerfair2023/serial_onverter.jpg)\\r\\n\\r\\nI brought the robot to work to see if everything would work after packing it in the case and traveling with it.  I had a hiccup where my joystick inputs weren\'t doing anything, but I figured this would have been a problem with the on/off switch as that\'s the only thing that would stop the joysticks from moving.  I checked and a wire was unplugged from the Arduino, and everything worked after that!  \\r\\n<iframe width=\\"315\\" height=\\"560\\"\\r\\nsrc=\\"https://youtube.com/embed/IsVxDqDYuvk?si=QfPQhgxrZzTwgiFX\\"\\r\\ntitle=\\"YouTube video player\\"\\r\\nframeborder=\\"0\\"\\r\\nallow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\"\\r\\nallowfullscreen></iframe>\\r\\n\\r\\nI wanted to get speakers working for this event, but I couldn\'t get it to work in time.  The audio quality was terrible from PWM on the Arduino, and there wasn\'t time to get a better solution.  Audio will have to wait.\\r\\n\\r\\nI tried getting the communication between body and head Arduino to work, but I had a few problems.  The serial port on my Arduino was now being used for SBUS, and the software serial library made by Arduino wasn\'t working in my case and was causing the servos to stutter.  Even with that, as I was testing somehow the Arduino in the head shorted, it got extremely hot and wasn\'t responsive to anything.  \\r\\n\\r\\n### Repainting Everything\\r\\nAt Long Beach Comic-Con, I asked the other builders how they finished their 3D prints to not look printed.  The suggestions were to:\\r\\n1) sand a lot before putting anything on, get rid of layer lines, and make it smooth\\r\\n2) use a filler, bondo spot putty, or filler primer\\r\\n3) sand the primer back to smooth everything out\\r\\n4) check if it needs another layer of primer/bondo and another sanding, repeat as needed\\r\\n\\r\\nWe also discussed how green isn\'t a Star Wars color.  And after I was told the green looked like guacamole, I wasn\'t feeling it.  So I decided to go to more of a yellow similar to the original reference drawing.\\r\\n\\r\\nI experimented on a small decorative piece on the leg, and focusing on step 1 to avoid a \\"garbage in, garbage out\\" scenario worked amazing.  Green is before, yellow is after.\\r\\n![](ocmakerfair2023/green_original.jpg)\\r\\n![](ocmakerfair2023/yellow_test.jpg)\\r\\n\\r\\nWith the amount I was going to be painting, I wanted a better solution to doing everything outside.  I built a ventilated spray paint booth, which I also have a project page on.\\r\\n![](ocmakerfair2023/spraypaint_booth.jpg)\\r\\n\\r\\nI started this for some of the larger parts to get the worst of it over with, sanding takes forever.  After realizing how important the initial first step is, I paid more attention to it.  After sanding I\'d fill holes with bondo and sand it back.  I\'d also mix bondo and acetone to get a consistency of thick paint so I could cover large areas.  Doing this meant I needed to repeat the filler primer step much less. \\r\\n![](ocmakerfair2023/sanding_more_parts.jpg)\\r\\n\\r\\nThe finish I could get was much better now.\\r\\n![](ocmakerfair2023/og_vs_sanded.jpg)\\r\\n![](ocmakerfair2023/post_filler_primer.jpg)\\r\\n\\r\\n### Testing and Fixes\\r\\n\\r\\nBecause of how overkill the motors are for this project, I needed to implement a slew rate to the drive.  The goal of this is to ramp up the power being sent to the motor.  If I tell the motors to go 30%, they should ramp up to that 30%.\\r\\n\\r\\nThis in itself is pretty simple.  I take the speed that was set to the motor, check if it\'s bigger or smaller than what we currently have, and add or subtract a constant to that number.  This loop iterates every 10ms and now we have a slew.\\r\\n```cpp\\r\\n// Slew the drive motors to avoid changes in motion that are too large\\r\\ndouble l_target = 0.0, r_target = 0.0;\\r\\ndouble l_current = 0.0, r_current = 0.0;\\r\\nconst double MAX = 2;\\r\\nvoid drive_set(double l, double r) {\\r\\n  if (drive_switch_enabled()) {\\r\\n    l_target = r_target = r_current = l_current = 0.0;\\r\\n    drive_set_raw(l_target, r_target);\\r\\n    return;\\r\\n  }\\r\\n  l_target = l;\\r\\n  r_target = r;\\r\\n\\r\\n  double max = fmax(fabs(l_target), fabs(r_target));\\r\\n  double l_add = MAX, r_add = MAX;\\r\\n  if (fabs(l_target) > fabs(r_target)) {\\r\\n    l_add = MAX;\\r\\n    r_add = MAX;\\r\\n  } else if (fabs(l_target) < fabs(r_target)) {\\r\\n    l_add = MAX;\\r\\n    r_add = MAX;\\r\\n  }\\r\\n\\r\\n  if (l_current > l_target)\\r\\n    l_current -= l_add;\\r\\n  else if (l_current < l_target)\\r\\n    l_current += l_add;\\r\\n\\r\\n  if (r_current > r_target)\\r\\n    r_current -= r_add;\\r\\n  else if (r_current < r_target)\\r\\n    r_current += r_add;\\r\\n\\r\\n  drive_set_raw(l_current, r_current);\\r\\n}\\r\\n```\\r\\n\\r\\nA problem that I noticed after driving with this code is driving in arcs felt wrong.  If I drove in an arc, where the left side would go at 30 power and the right side at 15, both sides would increase at the same rate until the slower side hit 15.  So the robot would drive forward and then turn, even though I never told it to go forward.  \\r\\n\\r\\nI solved this by scaling the slower side down by the ratio of `slower side / faster side` with this code and everything felt significantly better.\\r\\n```cpp\\r\\n  double max = fmax(fabs(l_target), fabs(r_target));\\r\\n  double min = fmin(fabs(l_target), fabs(r_target));\\r\\n  double l_add = MAX, r_add = MAX;\\r\\n  if (fabs(l_target) > fabs(r_target)) {\\r\\n    l_add = MAX;\\r\\n    r_add = MAX * (min / max);\\r\\n  } else if (fabs(l_target) < fabs(r_target)) {\\r\\n    l_add = MAX * (min / max);\\r\\n    r_add = MAX;\\r\\n  }\\r\\n```\\r\\n\\r\\nI wanted to change the sensitivity of the joysticks, so I added the same joystick curve I\'ve been using on my VEX robots which I explain [here](https://ez-robotics.github.io/EZ-Template/tutorials/joystick_curve). \\r\\n\\r\\nBut the drive still felt strange.  It can\'t point turn nicely because it has 4 wheels that don\'t slide well.  There is some code in FRC called curvature drive which is single-stick arcade but makes the robot feel like a typical RC car.  One axis is forward / backward, and the other axis controls \\"the angle the front wheels are facing\\" but in code.  With the implementation I\'m using I can\'t point turn anymore, but I couldn\'t before anyway so that doesn\'t bother me. \\r\\n```cpp\\r\\n  // Curvature Drive from\\r\\n  // https://github.com/OkapiLib/OkapiLib/blob/54995fd390aaf4d4949a516a76580c50b394912f/src/api/chassis/model/skidSteerModel.cpp#L140-L169\\r\\n  double scale = max_speed;\\r\\n  double forward = (joystick_curve_fwd(joystick_channel(LEFT_Y), curve_fwd)) / 127.0;\\r\\n  double curve = (joystick_curve_turn(joystick_channel(LEFT_X), curve_turn)) / 127.0;\\r\\n\\r\\n  double left_speed = forward + fabs(forward) * curve;\\r\\n  double right_speed = forward - fabs(forward) * curve;\\r\\n\\r\\n  // normalizes output\\r\\n  double faster_side = fmax(fabs(left_speed), fabs(right_speed));\\r\\n  if (faster_side > 1.0) {\\r\\n    left_speed /= faster_side;\\r\\n    right_speed /= faster_side;\\r\\n  }\\r\\n\\r\\n  left_speed = left_speed * scale;\\r\\n  right_speed = right_speed * scale;\\r\\n```\\r\\n\\r\\nThere is a seam between both halves of the body and this always bothered me.  I was going to try to make a strip that goes up along the seam so it\'s covered by something that looks like an intentional vertical line.  \\r\\n\\r\\nKiana suggested instead of that to just have something that wraps around the body and squeezes it all together.  I was skeptical because of the strange geometry of that part of the body, but after she drew this image I felt like it was worth it.\\r\\n![](ocmakerfair2023/drawn_seam_fixer.png)\\r\\n![](ocmakerfair2023/real_seam_fixer.jpg)\\r\\n\\r\\nI finished up the pelican case and added spots for the batteries and the controller. \\r\\n![](ocmakerfair2023/bottom_case.jpg)\\r\\n![](ocmakerfair2023/middle_case.jpg)\\r\\n![](ocmakerfair2023/top_case.jpg)\\r\\n\\r\\nI wanted to bring it to work again to make sure everything was still working, and good thing I did.  I was having a strange issue where the switch wasn\'t working again, but this time everything seemed like it was plugged in.  At this point there had been 2 problems with the switch, so after work, I reprogrammed the switch to be on the controller instead.  I brought it back to work the next day and everything was working perfectly. I added safety so that when the switch goes from disabled to enabled, nothing turns on for 3 seconds.\\r\\n\\r\\n### At OC Maker Faire 2023\\r\\n![](ocmakerfair2023/dd_walter.jpg)\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/QHBAFHdF71U?si=WKsknEyCu6PMA-Uy\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n![](lacomicon2023/r2_bully.jpg)\\r\\n\\r\\n---  \\r\\n## LA Comic Con 2023\\r\\nGoal: December 2-3, 2023\\r\\n### Plans\\r\\nThere is a lot I\'d like to change to the robot, but I can only give it so much time.  This is the priority list for changes I\'d like to make, and we\'ll get to as many as we can:\\r\\n- use gyros in the controller to decide when the controller is set down and disable the robot if it\'s set down for too long\\r\\n- fix the anything that broke after it drove off of a table\\r\\n- wire the head servos to the body\\r\\n- stop controller \\"activity warning\\" and brushless ESC\'s beeping when left alone for too long\\r\\n- redo the entire head tilt for a delta linkage\\r\\n- change ring gear for a wheel that\'s sprung into a track for longevity when kids try to spin the head  \\r\\n- speakers\\r\\n\\r\\n\\r\\n### Controller AFK Shutoff\\r\\nI want the robot to turn itself off when I set the controller down, but only sometimes.  When the eye/eyebrows are fully done, I\'d like to be able to leave the robot on and let everything animate on its own. \\r\\n\\r\\nThere is a switch on the controller to disable all head movement, and there\'s a switch on the controller to disable the drive.  If the drive is left on I want the robot to disable when I set the controller down.  But if the drive is off, nothing should turn off when I set the controller down.  \\r\\n\\r\\nI don\'t want the robot to turn off while I\'m using the joysticks, even if the robot is completely still.  Currently, I only check if the joysticks have been used recently and allow this function to run when they haven\'t, but I need to add every input on the controller to that list.  So only after no input has been touched for X amount of time will we start checking for the controller being set down. \\r\\n\\r\\nThen we check the position over time (velocity) of the controller to see if it\'s sitting.  If it is, a timer starts, and after that amount of time has passed the robot will shut off.\\r\\n\\r\\nThis needs a little less sensitivity to moving.  Currently, if the controller is on a table and someone walks nearby the controller thinks it\'s moving.\\r\\n\\r\\n```cpp\\r\\n  // Disable drive if the controller is set down for a certain amount of time\\r\\n  if (controller_switch_output & !are_joysticks_running()) {\\r\\n    // Current values\\r\\n    int cur_x = joystick_channel(GYRO_X);\\r\\n    int cur_y = joystick_channel(GYRO_Y);\\r\\n\\r\\n    // Figure out the velocity of the controller\\r\\n    int x = cur_x - last_x;\\r\\n    int y = cur_y - last_y;\\r\\n\\r\\n    last_x = cur_x;\\r\\n    last_y = cur_y;\\r\\n\\r\\n    // If X and Y velocity are 0, and either X or Y isn\'t currently at 0 degrees, start the timer\\r\\n    if (x == 0 && y == 0 && (cur_x != 0 || cur_y != 0))\\r\\n      afk_timer += 20;\\r\\n    else\\r\\n      afk_timer = 0;\\r\\n\\r\\n  } else {\\r\\n    afk_timer = 0;\\r\\n  }\\r\\n\\r\\n  // Once the timer has reached 2000, disable everything on the robot\\r\\n  if (afk_timer >= 2000) {\\r\\n    controller_switch_timer = false;\\r\\n    startup_switch_output = false;\\r\\n    last_switch_state = true;\\r\\n    controller_switch_timer = 0;\\r\\n    afk_timer = 0;\\r\\n    return;\\r\\n  }\\r\\n```\\r\\n\\r\\nI did this by adding a buffer to the velocity of the code above, where if it\'s less than 1 it\'ll treat it like 0. \\r\\n```cpp\\r\\n    // Give wiggle room for noise\\r\\n    x = abs(x) <= 1 ? 0 : x;\\r\\n    y = abs(y) <= 1 ? 0 : y;\\r\\n```\\r\\n\\r\\nThe data from the gyro seemed noisy when I would move quickly still, so I added an SMA filter to the gyro readings.  This was extremely sensitive before, and now all works as I expect it to. \\r\\n```cpp\\r\\n  // SMA filter for the gyros in the controller\\r\\n  if (gyro_x_vector.size() >= gyro_x_vector.max_size())\\r\\n    gyro_x_vector.remove(0);\\r\\n\\r\\n  if (gyro_y_vector.size() >= gyro_y_vector.max_size())\\r\\n    gyro_y_vector.remove(0);\\r\\n\\r\\n  gyro_x_vector.push_back(joystick_channel_raw(GYRO_X));\\r\\n  gyro_y_vector.push_back(joystick_channel_raw(GYRO_Y));\\r\\n\\r\\n  // int xx = 0, yy = 0;\\r\\n  int max = gyro_x_vector.size();\\r\\n  for (int i = 0; i < max; i++) {\\r\\n    gyro_x_output += gyro_x_vector[i];\\r\\n    gyro_y_output += gyro_y_vector[i];\\r\\n  }\\r\\n  gyro_x_output /= max;\\r\\n  gyro_y_output /= max;\\r\\n  ```\\r\\n\\r\\n### Fixing the Fall\\r\\nFirst, everything comes apart...\\r\\n![](lacomicon2023/PXL_20231122_210748901.jpg)\\r\\n\\r\\nAll of the damage went to the head.  A lot of mechanical parts that were hot glued on have fallen off, and some paint is chipped all around the eye. \\r\\n\\r\\nI\'m starting by hot-gluing everything back into place.  It\'s a pretty gross process, it isn\'t leading to consistency between both eyebrows which are meant to be the same.  The eye is a mess too- I saw another builder use springs instead of wire so nothing breaks when it\'s hit, and that\'s something I\'d like to use. \\r\\n\\r\\nAfter fixing everything mechanically it\'s shown me how unhappy I am with the construction of the head.  After this event, I need to find a better solution to my problems with it.  Maybe it\'s 3D printing a new head, or it\'s just making entire subsystems that are printed and get hot glued in, instead of relying on hot glue to index everything inside the head. Who could have guessed that would be inconsistent?\\r\\n\\r\\nSome paint scratched too.  I have two options for repairing scratches, I can either repaint it and continuously try to keep it perfect, or I can repair it and over time this will gain natural weathering.  I\'m going to fix it over time.  The front yellow plate fell off during the fall and the eye took a big scratch, exposing bondo spot putty that was used to fill some gaps. \\r\\n![](lacomicon2023/eye_before.jpg)\\r\\n\\r\\nThe color isn\'t an exact match, but it\'s hard to tell that my black acrylic paint was more matte than the rest of the head because the yellow part acts as a barrier. \\r\\n![](lacomicon2023/eye_after.jpg)\\r\\n\\r\\nThe body cracked a little at some weaker points in the design.  There isn\'t much scratched on the body though.\\r\\n![](lacomicon2023/boyd_before.jpg)\\r\\n\\r\\nI filled the parts that did scratch with some yellow paint and filled the vent with a lighter gray on the inside and gold around.  I like the idea of yellow exposing itself when the black scratches. \\r\\n![](lacomicon2023/body_after.jpg)\\r\\n\\r\\n### Wiring Head Servos to the Body\\r\\nI tried to find a place to plug the servos into the servo board but the pins on the servo board are completely inaccessible.  The opposite side of the blue board needs to be reached.\\r\\n![](lacomicon2023/PXL_20231122_222634312.jpg)\\r\\n\\r\\nWhere this looks from the other side. \\r\\n![](lacomicon2023/PXL_20231122_222628747.jpg)\\r\\n\\r\\nThe only solution I could come up with was to remove the servo board, desolder some pins, and flip them to the other side, which worked out.  Now to add wires the polycarbonate just has to be removed. \\r\\n![](lacomicon2023/flipped_pins.jpg)\\r\\n\\r\\nThen it\'s just wiring everything together and labeling all the wires.\\r\\n![](lacomicon2023/head_wired.jpg)\\r\\n\\r\\n### At LA Comic Con 2023\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/BFHmbZconYs?si=m7Rbp61tfYlYZbbu\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\n![](lacomicon2023/dd-3.jpg)\\r\\n![](lacomicon2023/group_photo.jpg)  \\r\\n![](lacomicon2023/bob_gurr.jpg)\\r\\n![](lacomicon2023/roxy.jpg)\\r\\n![](lacomicon2023/dd_and_grogu.jpg)\\r\\n![](lacomicon2023/walle_out.jpg)\\r\\n![](lacomicon2023/gil_and_grogu.jpg)\\r\\n![](lacomicon2023/gross_grogu_dd.jpg)\\r\\n![](lacomicon2023/trooper_dd.jpg)\\r\\n![](lacomicon2023/rusty.jpg)\\r\\n![](lacomicon2023/dd_gil_grogu.jpg)\\r\\n\\r\\n---\\r\\n## Next Con?\\r\\nGoal: ?\\r\\n\\r\\n### Plans\\r\\nI\'d like to completely redesign the head entirely.  As I mentioned previously, indexing anything on a bowl has proven challenging.  I can design it all to be 3D printed and have some hole pattern on the inside so I can design mounts for servos, speakers, etc.  I can make the actual shell that you look at as independent panels, and that will help add detail and break up the perfectly smooth surface that the bowl has currently.  \\r\\n\\r\\nTo give the head more expression I\'d like to change the head tilt to a delta linkage as shown in the video below.  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/aXTe7icWDPM?si=si2PP7KV2IxK4Gou\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\nThe ring gear should be changed out for a wheel that gets spring loaded into the head.  This will keep the robot safe from kids pulling on it.  But with this, I\'ll need to add a sensor to the head to track rotation so I can animate positions and run PID through it.  \\r\\n\\r\\n**And of course, the robot needs speakers and LEDS!**"},{"id":"pure-pursuit","metadata":{"permalink":"/projects/pure-pursuit","source":"@site/projects/2024-02-05-pure-pursuit/index.md","title":"Pure Pursuit","description":"I made a pure-pursuit algorithm for mecanum drive and tank drives.","date":"2024-02-05T00:00:00.000Z","formattedDate":"February 5, 2024","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"software","permalink":"/projects/tags/software"},{"label":"open-source","permalink":"/projects/tags/open-source"}],"readingTime":11.956666666666667,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"pure-pursuit","title":"Pure Pursuit","authors":["jess"],"tags":["vex","software","open-source"]},"unlisted":false,"prevItem":{"title":"DD-3","permalink":"/projects/dd-3"},"nextItem":{"title":"EZ-Template","permalink":"/projects/about-ez-template"}},"content":"import Tabs from \'@theme/Tabs\';\\r\\nimport TabItem from \'@theme/TabItem\';\\r\\n\\r\\nI made a [pure-pursuit](https://www.mathworks.com/help/nav/ug/pure-pursuit-controller.html) algorithm for [mecanum drive](https://github.com/EZ-Robotics/EZ-Mecanum) and [tank drives](https://github.com/EZ-Robotics/EZ-Tank-Odom).  \\r\\n\\r\\n![](banner.png)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nPure Pursuit is a tracking algorithm that allows a robot to follow a given path by following a point some distance ahead like a carrot on a stick.  It requires some way of knowing where your current position is and a generated path.\\r\\n\\r\\n## Position Tracking\\r\\nPosition tracking is a piece of code that given 2 or 3 encoders you can extrapolate the X, Y, and angle of the robot.\\r\\n\\r\\nThis is explained far better by others, and here are the resources that I used:  \\r\\n[5225A Tracking Documentation](https://wiki.purduesigbots.com/software/odometry)  \\r\\n[QUEEN Video Explanation](https://www.youtube.com/watch?v=_T6KHywSP58)\\r\\n\\r\\nThis code relies on the speed at which sensors update, because it figures out the change in position over the time it takes for sensors to update, and adds that change to a current global value.  \\r\\n\\r\\n`LEFT_OFFSET` and `RIGHT_OFFSET` are the \\"track width\\".  This is the width between the tracking wheels on the robot,  I have them split into 2 variables because technically they do not need to be the same number.  \\r\\n`CENTER_OFFSET` is the distance from a perpendicular tracking wheel to the turning center of the robot.  This number can be anything, but the nicest way is for this to align with the robot\'s turning center.  This can be tuned by turning the robot in place and adjusting this number until the XY stops rotating around the robot. \\r\\n```cpp\\r\\nvoid tracking_task() {\\r\\n  double l_current = 0, r_current = 0;\\r\\n  double c_current = 0;\\r\\n  double l = 0, r = 0, c = 0;  // delta distance\\r\\n  double l_last = 0, r_last = 0, c_last = 0;\\r\\n  double radius_r = 0, radius_c = 0, h = 0, h2 = 0;  // rad for big circle\\r\\n  double beta = 0, alpha = 0, theta = 0;\\r\\n  double Xx = 0, Yy = 0, Xy = 0, Yx = 0;\\r\\n  while (true) {\\r\\n    l_current = get_raw_left();\\r\\n    r_current = get_raw_right();\\r\\n    c_current = get_raw_center();\\r\\n\\r\\n    l = l_current - l_last;\\r\\n    r = r_current - r_last;\\r\\n    c = c_current - c_last;\\r\\n\\r\\n    l_last = l_current;\\r\\n    r_last = r_current;\\r\\n    c_last = c_current;\\r\\n\\r\\n    double width = LEFT_OFFSET + RIGHT_OFFSET;\\r\\n\\r\\n    // diff between wheels for correcting turning\\r\\n    theta = (l - r) / width;\\r\\n\\r\\n    if (theta != 0) {\\r\\n      radius_r = r / theta;\\r\\n      beta = theta / 2.0;\\r\\n      h = ((radius_r + RIGHT_OFFSET) * sin(beta)) * 2.0;\\r\\n      radius_c = c / theta;\\r\\n      h2 = (radius_c + CENTER_OFFSET) * 2.0 * sin(beta);\\r\\n    } else {\\r\\n      h = l;\\r\\n      h2 = 0;\\r\\n      beta = 0;\\r\\n    }\\r\\n\\r\\n    alpha = angle_rad + beta;\\r\\n\\r\\n    Xx = h2 * cos(alpha);\\r\\n    Xy = h2 * -sin(alpha);\\r\\n    Yx = h * sin(alpha);\\r\\n    Yy = h * cos(alpha);\\r\\n\\r\\n    current.x += (Xx + Yx) / TICK_PER_INCH;\\r\\n    current.y += (Xy + Yy) / TICK_PER_INCH;\\r\\n    angle_rad += theta;\\r\\n    current.theta = to_deg(angle_rad);\\r\\n\\r\\n    pros::delay(1);\\r\\n  }\\r\\n}\\r\\n```\\r\\n## Mecanum Drive\\r\\nMecanum wheels allow the robot to move forward / backward and side to side.  These wheels get their own section here because they are effectively a cheat code for getting this code to work.  Because they can strafe, any error that\'s accumulated along the way can be accounted for.  With a drivetrain that cannot strafe, if you aren\'t following the path as exactly as you can, it becomes extremely difficult to account for it later.  This is why I chose this drive first, it allows me to go through all of this code without the problems that a typical drivetrain would give me. \\r\\n![](mecan_cad.png)\\r\\n\\r\\n### Point to Point\\r\\nTo get the robot to move to a new target point, I need to calculate the amount the robot needs to move in the X direction, the amount the robot needs to move in the Y direction, and the amount the robot needs to move in turn. \\r\\n\\r\\nThe direction the robot moves will change depending on the desired end angle. Some trigonometry is done to figure out the relative directions the robot needs to go, as while the robot turns the motor powers will all change.\\r\\n\\r\\nThe final thing to do is scale everything down.  If X output and Y output both exceed the maximum power that can be sent to the motors, even if one is magnitudes larger than the other, the robot will end up going straight.  We solve this by scaling everything down to a larger number.\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/ZbMDKJ0zA3o?si=T7nrteA03m6vQWDE\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\n```cpp\\r\\nvoid point_to_point() {\\r\\n  // Compute PID\\r\\n  xPID.compute(current.x);\\r\\n  yPID.compute(current.y);\\r\\n  aPID.compute(get_angle());\\r\\n\\r\\n  // Vector math\\r\\n  double angle = to_rad(get_angle());\\r\\n  double raw_x_power = (xPID.output * cos(angle)) - (yPID.output * sin(angle));\\r\\n  double raw_y_power = (yPID.output * cos(angle)) + (xPID.output * sin(angle));\\r\\n  double raw_a_power = aPID.output;\\r\\n\\r\\n  // Set output powers\\r\\n  int x_output = raw_x_power;\\r\\n  int y_output = raw_y_power;\\r\\n  int a_output = clip_num(raw_a_power, 60, -60);\\r\\n  int max_xy = 110;\\r\\n\\r\\n  // Vector scaling \\r\\n  if (fabs(raw_x_power) > max_xy || fabs(raw_y_power) > max_xy) {\\r\\n    if (fabs(raw_x_power) > fabs(raw_y_power)) {\\r\\n      double scale = max_xy / fabs(raw_x_power);\\r\\n      x_output = clip_num(raw_x_power, max_xy, -max_xy);\\r\\n      y_output = raw_y_power * scale;\\r\\n    } else {\\r\\n      double scale = max_xy / fabs(raw_y_power);\\r\\n      x_output = raw_x_power * scale;\\r\\n      y_output = clip_num(raw_y_power, max_xy, -max_xy);\\r\\n    }\\r\\n  } else {\\r\\n    x_output = raw_x_power;\\r\\n    y_output = raw_y_power;\\r\\n  }\\r\\n\\r\\n  // Set motors\\r\\n  raw_set_drive(x_output, y_output, a_output);\\r\\n}\\r\\n```\\r\\n\\r\\nMecanum drives that use the VRC wheels are slower when strafing than in forward / backward.  Because of this, I knew I\'d want a mode where the robot would go straight for most of the motion and then turn at the end to face the desired angle. \\r\\n\\r\\nThis piece of code was added to the above function.  It modifies the target angle depending on how far away the robot is from the target position.  If it\'s more than 12\\" away, the robot will go faster and face the target position.  Once the robot is within 12\\" of the target it\'ll start to rotate to the desired angle. \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/pIiadWcYlac?si=JW_q3pCaxF9RjtR2\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\n```cpp\\r\\n  // Add for direction\\r\\n  int add = dir == REV ? 180 : 0;\\r\\n\\r\\n  // Set angle target\\r\\n  double a_target;\\r\\n  if (fast_move) {\\r\\n    if (fabs(distance_to_point(target.x, target.y)) < 12) {\\r\\n      only_look_at_point = false;\\r\\n      a_target = target.theta;\\r\\n    } else {\\r\\n      only_look_at_point = true;\\r\\n    }\\r\\n  } else {\\r\\n    a_target = target.theta;\\r\\n  }\\r\\n\\r\\n  if (only_look_at_point) {\\r\\n    a_target = absolute_angle_to_point(target.x, target.y) + add;\\r\\n  }\\r\\n\\r\\n  // Compute angle PID and find the shortest path to the angle\\r\\n  aPID.set_target(relative_angle_to_point(a_target));\\r\\n  aPID.compute(0);\\r\\n```\\r\\n\\r\\n### Paths with Strafe\\r\\nThe paths the robot will follow will be points the user inputs.  In the example below, the robot will start at (0, 0), travel to (0, 24), then to (24, 24), then back to (0, 0).\\r\\n```cpp\\r\\nvoid autonomous() {\\r\\n  pure_pursuit(\\r\\n        {{{0, 24, 0}, FAST_MOVE_FWD},\\r\\n         {{24, 24, 0}, FAST_MOVE_FWD},\\r\\n         {{0, 0, 0}, FAST_MOVE_REV}});\\r\\n  wait_drive();\\r\\n}\\r\\n```\\r\\n\\r\\nOnce I have a list of points, to decide which point to go to next I see how far away the robot is from the next point.  The target position gets shifted until we\'re looking at a point that is a distance away from the robot, and it keeps changing until we\'re at the final position in the list. \\r\\n```cpp\\r\\nvoid pure_pursuit() {\\r\\n  raw_move_odom(movements[pp_index]);\\r\\n\\r\\n  if (fabs(distance_to_point(movements[pp_index].target.x, movements[pp_index].target.y)) < 5) {\\r\\n    pp_index++;\\r\\n    if (pp_index >= movements.size()) {\\r\\n      pp_index = movements.size() - 1;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  point_to_point();\\r\\n}\\r\\n```\\r\\n\\r\\nI cleaned up how the \\"turn type\\" is handled.  There are now 3 turn types:  \\r\\n`FAST_MOVE` where the robot faces the target position and within 12\\" will move to the final angle\\r\\n`LOOK_AT_TARGET` where the robot doesn\'t care about the end angle, and will always look at the target\\r\\n`HOLD_ANGLE` where the robot will just hold its angle\\r\\n\\r\\nI had to add `LOOK_AT_TARGET` because the distance away from the current target was less than 12\\", and the robot would always hold an angle even if I didn\'t want it to.  This lets me use `FAST_MOVE` as intended, and have all of my injected points follow `LOOK_AT_TARGET`.  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/aUpCYLBIhE0?si=LELL8e9J1XWCjrY3\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\n```cpp\\r\\n  // Add for direction\\r\\n  int add = current_turn_type == FAST_MOVE_REV || LOOK_AT_TARGET_REV ? 180 : 0;\\r\\n\\r\\n  // Set angle target\\r\\n  switch (current_turn_type) {\\r\\n    // Looks at the target until final distance then goes to the final angle\\r\\n    case FAST_MOVE_FWD:\\r\\n    case FAST_MOVE_REV:\\r\\n      if (fabs(distance_to_point(target, current)) < TURN_FAST_MOVE) {\\r\\n        a_target = target.theta;\\r\\n      } else {\\r\\n        a_target = absolute_angle_to_point(target, current) + add;\\r\\n      }\\r\\n      break;\\r\\n    // Looks at target the entire motion\\r\\n    case LOOK_AT_TARGET_FWD:\\r\\n    case LOOK_AT_TARGET_REV:\\r\\n      if (fabs(distance_to_point(target, current)) > STOP_UPDATING_ANGLE) {\\r\\n        a_target = absolute_angle_to_point(target, current) + add;\\r\\n      }\\r\\n      break;\\r\\n    // Holds angle the entire motion\\r\\n    case HOLD_ANGLE:\\r\\n      a_target = target.theta;\\r\\n    default:\\r\\n      break;\\r\\n  }\\r\\n```\\r\\n\\r\\n### Point Injection and Path Smoothing\\r\\nThis is based on the [Dawgma Adaptive Pure Pursuit paper](https://www.chiefdelphi.com/t/paper-implementation-of-the-adaptive-pure-pursuit-controller/166552).\\r\\n\\r\\nUsing the path following above, I want the code to internally add points every 1\\" along the path.  This will make the robot care about how it gets somewhere instead of blindly aiming towards a single point.  This code creates a new point that\'s 1\\" away from the current point on the way to the next big target point, and repeats for every input point.  \\r\\n```cpp\\r\\n// Inject point based on https://www.chiefdelphi.com/t/paper-implementation-of-the-adaptive-pure-pursuit-controller/166552\\r\\nstd::vector<odom> inject_points(std::vector<odom> imovements) {\\r\\n  injected_pp_index.clear();\\r\\n  // Create new vector that includes the starting point\\r\\n  std::vector<odom> input = imovements;\\r\\n  input.insert(input.begin(), {{{target.x, target.x, imovements[0].target.theta}, imovements[0].turn_type, imovements[0].max_xy_speed, imovements[0].max_turn_speed}});\\r\\n\\r\\n  std::vector<odom> output;  // Output vector\\r\\n  int output_index = -1;     // Keeps track of current index\\r\\n\\r\\n  // This for loop runs for how many points there are minus one because there is one less vector than points\\r\\n  for (int i = 0; i < input.size() - 1; i++) {\\r\\n    // Figure out how many points fit in the vector\\r\\n    int num_of_points_that_fit = (distance_to_point(input[i + 1].target, input[i].target)) / SPACING;\\r\\n\\r\\n    // Add parent point\\r\\n    // Make sure the robot is looking at next point\\r\\n    output.push_back({input[i].target,\\r\\n                      input[i + 1].turn_type,\\r\\n                      input[i].max_xy_speed,\\r\\n                      input[i].max_turn_speed});\\r\\n    output_index++;\\r\\n    injected_pp_index.push_back(output_index);\\r\\n\\r\\n    // Add the injected points\\r\\n    for (int j = 0; j < num_of_points_that_fit; j++) {\\r\\n      // Calculate the new point with known information: hypot and angle\\r\\n      double angle_to_point = absolute_angle_to_point(input[i + 1].target, input[i].target);\\r\\n      pose new_point = vector_off_point(SPACING, {output[output_index].target.x, output[output_index].target.y, angle_to_point});\\r\\n\\r\\n      // Make sure the robot is looking at the next point\\r\\n      turn_types turn;\\r\\n      if ((input[i + 1].turn_type == FAST_MOVE_REV || input[i + 1].turn_type == FAST_MOVE_FWD) && fabs(distance_to_point(input[i + 1].target, new_point)) > TURN_FAST_MOVE - LOOK_AHEAD) {\\r\\n        turn = input[i + 1].turn_type == FAST_MOVE_REV ? LOOK_AT_TARGET_REV : LOOK_AT_TARGET_FWD;\\r\\n      } else {\\r\\n        turn = input[i + 1].turn_type;\\r\\n      }\\r\\n\\r\\n      // Push new point to vector\\r\\n      output.push_back({{new_point.x, new_point.y, input[i + 1].target.theta},\\r\\n                        turn,\\r\\n                        input[i + 1].max_xy_speed,\\r\\n                        input[i + 1].max_turn_speed});\\r\\n      output_index++;\\r\\n    }\\r\\n    // Make sure the final point is there\\r\\n    output.push_back(input[i + 1]);\\r\\n    output_index++;\\r\\n  }\\r\\n\\r\\n  // Return final vector\\r\\n  return output;\\r\\n}\\r\\n```\\r\\n\\r\\nAnother benefit of injecting points is we get more ability to smooth the path.  The Dawgma paper cites another paper by [James Teow on path smoothing for robots](https://medium.com/@jaems33/understanding-robot-motion-path-smoothing-5970c8363bc4).  I translated his code from Python to C++ and got the below code.  A slight path smoothing helps get rid of impossible sharp corners and gives the robot a path that more closely represents what it\'s going to follow anyway.  \\r\\n```cpp\\r\\n// Path smoothing based on https://medium.com/@jaems33/understanding-robot-motion-path-smoothing-5970c8363bc4\\r\\nstd::vector<odom> smooth_path(std::vector<odom> ipath, double weight_smooth, double weight_data, double tolerance) {\\r\\n  double path[500][2];\\r\\n  double new_path[500][2];\\r\\n\\r\\n  // Convert odom to array\\r\\n  for (int i = 0; i < ipath.size(); i++) {\\r\\n    path[i][0] = new_path[i][0] = ipath[i].target.x;\\r\\n    path[i][1] = new_path[i][1] = ipath[i].target.y;\\r\\n  }\\r\\n\\r\\n  double change = tolerance;\\r\\n\\r\\n  while (change >= tolerance) {\\r\\n    change = 0.0;\\r\\n    for (int i = 1; i < ipath.size() - 2; i++) {\\r\\n      for (int j = 0; j < 2; j++) {\\r\\n        double x_i = path[i][j];\\r\\n        double y_i = new_path[i][j];\\r\\n        double y_prev = new_path[i - 1][j];\\r\\n        double y_next = new_path[i + 1][j];\\r\\n\\r\\n        double y_i_saved = y_i;\\r\\n        y_i += weight_data * (x_i - y_i) + weight_smooth * (y_next + y_prev - (2.0 * y_i));\\r\\n        new_path[i][j] = y_i;\\r\\n\\r\\n        change += abs(y_i - y_i_saved);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // Convert array to odom\\r\\n  std::vector<odom> output = ipath;  // Set output to input so target angles, turn types, and speed hold\\r\\n  // Overwrite x and y\\r\\n  for (int i = 0; i < ipath.size(); i++) {\\r\\n    output[i].target.x = new_path[i][0];\\r\\n    output[i].target.y = new_path[i][1];\\r\\n  }\\r\\n\\r\\n  return output;\\r\\n}\\r\\n```\\r\\n\\r\\n### Final Mecanum\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/pVcdgffsMnA?si=P3Cc8XRpN6KGd6hI\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/A_Q_yBHhWSY?si=9qDZo20ImXHNNA5K\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\n## Tank Drive\\r\\nNow the goal is to get this all working properly on a tank drive setup.  I have a kind of working version [here](https://github.com/EZ-Robotics/peewee) but I didn\'t have a lot of time with that robot to iron everything out.  \\r\\n\\r\\nBelow is my rewrite of this about a year later.  This uses v3.0.0 of [EZ-Template](https://ez-robotics.github.io/EZ-Template/) as a base.  \\r\\n\\r\\n### Tracking Differences\\r\\nFor the tank drives, I wanted to play with using no tracking wheels.  Tracking wheels are free-spinning wheels that have sensors on them, and they are mounted on \\"suspension\\" so they always contact the ground even if the robot lifts off the ground.  \\r\\n\\r\\nThe encoders inside of V5 motors have been shockingly good, I\'ve had very consistent results using them.  Not having tracking wheels means my robot will not be able to correct for movements that the robot doesn\'t read.  So I won\'t be able to push the robot and have it fully correct.  This will only be able to correct for movements the robot thinks have happened, so if there\'s a wheel slip the robot won\'t be able to account for that either.  These are all problems that exist with the consistent autonomous routines that have been made previously with the built-in encoders, so for this, I felt it was fine.  \\r\\n\\r\\n### Point to Point\\r\\n\\r\\n#### Target Angle \\r\\nAn issue that isn\'t had with the mecanum drive is accounting for the target heading because this drive cannot drive.  If we set the target angle to be the angle between our current position and target, we run into problems where the angle doesn\'t scale with distance.  If we\'re at (0.5, 11.5) trying to go to (12, 12) the robot will turn 45 degrees to move this half-inch.  As the robot moves this issue will be compounded causing oscillation in the target.  \\r\\n\\r\\nThis can be solved by projecting a new point (only used for this angle calculation) that follows the line between the robot and the real target.  There are two possible solutions for this though, because we can project forward or backward.  So in this function below, I figure out both of these solutions and pick the one farther away from where the robot targets.  \\r\\n```cpp\\r\\n// Find the angle to face during movements\\r\\nstd::vector<pose> Drive::find_point_to_face(pose current, pose target, bool set_global) {\\r\\n  double tx_cx = target.x - current.x;\\r\\n  double m = 0.0;\\r\\n  double angle = 0.0;\\r\\n  if (tx_cx != 0) {\\r\\n    m = (target.y - current.y) / tx_cx;\\r\\n    angle = 90.0 - util::to_deg(atan(m));\\r\\n  }\\r\\n  pose ptf1 = util::vector_off_point(LOOK_AHEAD, {target.x, target.y, angle});\\r\\n  pose ptf2 = util::vector_off_point(LOOK_AHEAD, {target.x, target.y, angle + 180});\\r\\n\\r\\n  if (set_global) {\\r\\n    double ptf1_dist = util::distance_to_point(ptf1, current);\\r\\n    double ptf2_dist = util::distance_to_point(ptf2, current);\\r\\n    if (ptf1_dist > ptf2_dist) {\\r\\n      ptf1_running = true;\\r\\n    } else {\\r\\n      ptf1_running = false;\\r\\n    }\\r\\n  }\\r\\n  point_to_face = {ptf1, ptf2};\\r\\n\\r\\n  return {ptf1, ptf2};\\r\\n}\\r\\n```\\r\\n\\r\\n#### Overshooting\\r\\nThe biggest issue (and difference) with implementing this on a tank drive vs a mecanum drive is how overshooting is handed.  \\r\\n\\r\\nWith the mecanum code, all of the math is done based on `target x - current x`.  This gives a direction, as it would return positive or negative depending on what the value of each one is.  \\r\\n\\r\\nWith the tank code, you have to set your XY PID to the distance between the robot and the target.  The distance formula can give this to us, but it removes any negative values.  In practice, this means the robot will slow down as it approaches the target, but once it passes the target the robot will continue to move.  \\r\\n  <Tabs\\r\\n  groupId=\\"ex1\\"\\r\\n  defaultValue=\\"v2\\"\\r\\n  values={[\\r\\n    { label: \'Tank\',  value: \'v2\', },\\r\\n    { label: \'Mecanum\',  value: \'v3\', },\\r\\n  ]\\r\\n}>\\r\\n\\r\\n<TabItem value=\\"v2\\">\\r\\n\\r\\n```cpp\\r\\n// Compute angle PID and find the shortest path to the angle\\r\\naPID.set_target(relative_angle_to_point(a_target));\\r\\naPID.compute(0);\\r\\n\\r\\n// Compute xy PID\\r\\nxyPID.set_target(distance_to_point(temp_xy_target, current) * dir);\\r\\nxyPID.compute(0);\\r\\n\\r\\n// Raw outputs\\r\\ndouble xy_raw_output = xyPID.output * cos(to_rad(relative_angle_to_point(a_target))); // Scale this based on how far away our angle is to target\\r\\ndouble a_raw_output = aPID.output;\\r\\n```\\r\\n\\r\\n</TabItem>\\r\\n\\r\\n\\r\\n<TabItem value=\\"v3\\">\\r\\n\\r\\n```cpp\\r\\ndouble angle = to_rad(get_angle());\\r\\ndouble raw_x_power = (xPID.output * cos(angle)) - (yPID.output * sin(angle));\\r\\ndouble raw_y_power = (yPID.output * cos(angle)) + (xPID.output * sin(angle));\\r\\ndouble raw_a_power = aPID.output;\\r\\n```\\r\\n\\r\\n\\r\\n\\r\\n</TabItem>\\r\\n</Tabs>\\r\\n\\r\\nI attempted this last year with cross-product.  This would work if we were at (0, 0) going to (0, 24), but would not work going from (0, 24) to (0, 0), as all of the values flip and it leaves us in the same situation.  \\r\\n```cpp\\r\\n// Check to see if we\'ve passed target\\r\\npose b = vector_off_point(24, {movements.back().target.x, movements.back().target.y, a_target + 90});\\r\\npose a = vector_off_point(24, {movements.back().target.x, movements.back().target.y, a_target - 90});\\r\\npose c = current;\\r\\nint there = sgn(((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)));  // cross product to decide if above/below line\\r\\n\\r\\nif (there == 1)\\r\\n  passed_target = current_turn_type == FWD ? true : false;\\r\\nelse if (there == -1)\\r\\n  passed_target = current_turn_type == REV ? true : false;\\r\\n```\\r\\n\\r\\nThe problem that I kept running into was needing a line perpendicular to the robot to decide when the robot was past the target.  This works sometimes if that line ends up being the X or Y axis, but on weird angles this becomes tricky.  \\r\\n\\r\\nMy solution was to make that line always be the X-axis.  I translate and rotate the target point so the robot is in positive Y always coming down to (0, 0). \\r\\n\\r\\nFor example, if I\'m currently at (0, 0) trying to go to (12, 12), the function below will simulate my target being (0, 0) and the robot currently being at (0, 16.9).  Now instead of using the distance formula to decide how far we are, we can just return the Y-axis of our new simulated current position.  \\r\\n```cpp\\r\\n// Returns a distance that the robot is away from the target, but this keeps sign.\\r\\ndouble Drive::is_past_target(pose target, pose current) {\\r\\n  // Translated current x, y translated around origin\\r\\n  double fakek_y = (current.y - target.y);\\r\\n  double fakek_x = (current.x - target.x);\\r\\n\\r\\n  // Angle to face translated around origin\\r\\n  pose ptf;\\r\\n  ptf.y = point_to_face[!ptf1_running].y - target.y;\\r\\n  ptf.x = point_to_face[!ptf1_running].x - target.x;\\r\\n  int add = current_turn_type == REV ? 180 : 0;\\r\\n  double fake_angle = util::to_rad((util::absolute_angle_to_point(ptf, {fakek_x, fakek_y})) + add);\\r\\n\\r\\n  // Rotate around the origin\\r\\n  double fake_x = (fakek_x * cos(fake_angle)) - (fakek_y * sin(fake_angle));\\r\\n  double fake_y = (fakek_y * cos(fake_angle)) + (fakek_x * sin(fake_angle));\\r\\n\\r\\n  return fake_y;\\r\\n}\\r\\n```\\r\\n\\r\\n#### Combining Both \\r\\nThose were the two big problems I was fighting to get this code to work.  I\'m sure some optimizations can be done (when are there not), but all of this seems to be stable.  \\r\\n\\r\\nThe iteration for this is similar to the mecanum drive, just using all of the new math talked about above.  \\r\\n```cpp\\r\\n// Odom To Point Task\\r\\nvoid Drive::ptp_task() {\\r\\n  // Compute angle\\r\\n  int add = current_turn_type == REV ? 180 : 0;                                                       // Decide if going fwd or rev\\r\\n  double a_target = util::absolute_angle_to_point(point_to_face[!ptf1_running], odom_current) + add;  // Calculate the point for angle to face\\r\\n  aPID.target_set(util::wrap_angle(a_target - drive_imu_get()));                                      // Constrain error to -180 to 180\\r\\n  aPID.compute(0);\\r\\n\\r\\n  // Decide if we\'ve passed the target or not\\r\\n  int dir = (current_turn_type == REV ? -1 : 1);                                                          // If we\'re going backwards, add a -1\\r\\n  int flipped = util::sgn(is_past_target(odom_target, odom_current)) != util::sgn(past_target) ? -1 : 1;  // Check if we\'ve flipped directions to what we started\\r\\n\\r\\n  // Compute xy PID\\r\\n  double temp_target = fabs(is_past_target(odom_target, odom_current));  // Use this instead of distance formula to fix impossible movements\\r\\n  xyPID.target_set(temp_target * dir * flipped);\\r\\n  xyPID.compute(0);\\r\\n\\r\\n  // Prioritize turning by scaling xy_out down\\r\\n  double cos_scale = cos(util::to_rad(aPID.target_get()));\\r\\n  double xy_out = xyPID.output * cos_scale;\\r\\n\\r\\n  // Raw outputs\\r\\n  double l_out = xy_out + aPID.output;\\r\\n  double r_out = xy_out - aPID.output;\\r\\n\\r\\n  // Compute slew\\r\\n  slew_left.iterate(drive_sensor_left());\\r\\n  slew_right.iterate(drive_sensor_right());\\r\\n\\r\\n  // Vector scaling so nothing can be larger than max speed\\r\\n  double max_slew_out = fmin(slew_left.output(), slew_right.output());\\r\\n  // When left and right slew are disabled, scale max speed by the turn scaler so the robot goes slower in curves\\r\\n  if (fabs(l_out) > max_slew_out || fabs(r_out) > max_slew_out) {\\r\\n    if (fabs(l_out) > fabs(r_out)) {\\r\\n      r_out = r_out * (max_slew_out / fabs(l_out));\\r\\n      l_out = util::clamp(l_out, max_slew_out, -max_slew_out);\\r\\n    } else {\\r\\n      l_out = l_out * (max_slew_out / fabs(r_out));\\r\\n      r_out = util::clamp(r_out, max_slew_out, -max_slew_out);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // Set motors\\r\\n  if (drive_toggle)\\r\\n    private_drive_set(l_out, r_out);\\r\\n\\r\\n  // This is for wait_until\\r\\n  leftPID.compute(drive_sensor_left());\\r\\n  rightPID.compute(drive_sensor_right());\\r\\n}\\r\\n```\\r\\n\\r\\n### Final Tank\\r\\nI implemented point injection and path smoothing from the mecanum code and this was able to follow paths now.  \\r\\n\\r\\nMy PID tuning for this is questionable, but the robot is successfully following all of the paths I\'ve given it.  Future improvements would be to implement more \\"awareness\\" for turning vs driving, and there was discussion about making the lookahead point variable based on how far away the angles target is too (increase for straight movements, shorten for turns).  This could be fun to play with in the future, but for now, this project is complete for me.  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/AY-8lzsPBVA?si=MYc5QOHDj7xkOo3s\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/BQ13qwDPhdI?si=D4GbmNuB0uyazOHW\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>"},{"id":"about-ez-template","metadata":{"permalink":"/projects/about-ez-template","source":"@site/projects/2024-01-28-ez-template/index.md","title":"EZ-Template","description":"EZ-Template is a simple plug-and-play PROS template that handles drive-base functions for VEX robots.","date":"2024-01-28T00:00:00.000Z","formattedDate":"January 28, 2024","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"mentoring","permalink":"/projects/tags/mentoring"},{"label":"tutorials","permalink":"/projects/tags/tutorials"},{"label":"software","permalink":"/projects/tags/software"},{"label":"open source","permalink":"/projects/tags/open-source"},{"label":"wip","permalink":"/projects/tags/wip"}],"readingTime":3.34,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"about-ez-template","title":"EZ-Template","authors":["jess"],"tags":["vex","mentoring","tutorials","software","open source","wip"]},"unlisted":false,"prevItem":{"title":"Pure Pursuit","permalink":"/projects/pure-pursuit"},"nextItem":{"title":"PVC Bipod","permalink":"/projects/pvc-bipod"}},"content":"import Tabs from \'@theme/Tabs\';\\r\\nimport TabItem from \'@theme/TabItem\';\\r\\n\\r\\n[EZ-Template](https://ez-robotics.github.io/EZ-Template/) is a simple plug-and-play PROS template that handles drive-base functions for VEX robots.  \\r\\n\\r\\n![](banner.jpg)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n---\\r\\n:::note\\r\\n\\r\\nEZ-Template has its own website for documentation [here](https://ez-robotics.github.io/EZ-Template/).\\r\\n\\r\\n:::\\r\\n\\r\\n## About\\r\\nMany students using VEXcode rely on the built-in [Drivetrain class](https://www.youtube.com/watch?v=JGGtvVNTGJw), but it often falls short in addressing the nuances of creating consistent autonomous routines, leading to frustration for new programmers. Issues like wheel slop and mechanical obstructions can be challenging to diagnose, causing students to lose interest in robotics.\\r\\n\\r\\nEZ-Template solves these problems by giving simple code that has been tested to work.  If something goes wrong, a student can try to tune the PID after fixing mechanical problems (which you can\'t do in VEXcode).  It eliminates one point of failure to keep students more interested in robotics.  \\r\\n\\r\\nThis project taught me the importance of listening to user feedback and making adjustments accordingly.  I got feedback that users would prefer instructions in the code rather than figure it out from scratch in the docs, so I made sure every version was released with functions used in an example project.\\r\\n\\r\\n## [v1.x](https://github.com/EZ-Robotics/EZ-Template/tree/f4c287dc3cea8c95cdbbd47939ef41c1d5a2f749)\\r\\n### About\\r\\nThe goal of EZ-Template shifted over time. This started as my [codebase on my Tower Takeover robot](https://github.com/EZ-Robotics/EZ-GOOFY), and as I progressed through Change Up I got increasingly annoyed at how convoluted it was to give the code all the information it needed.  I made a brand new project and copied over all of my drive base code, and had a [single configuration file](https://github.com/EZ-Robotics/EZ-Template/blob/f4c287dc3cea8c95cdbbd47939ef41c1d5a2f749/include/EZ-Template/setup.hpp).  \\r\\n\\r\\n### Features\\r\\n- simple to set up a project\\r\\n- drive, turn, and swing turn PID \\r\\n- speed ramp-up for driving\\r\\n- asynchronous PID with blocking functions until settled and until a specific position has come\\r\\n- joystick input curves\\r\\n- live adjustment of the curves through the controller\\r\\n- basic autonomous selector\\r\\n\\r\\n### Issues\\r\\nThe code for this version was less than ideal.  The [main file was ~500 lines](https://github.com/EZ-Robotics/EZ-Template/blob/f4c287dc3cea8c95cdbbd47939ef41c1d5a2f749/src/EZ-Template/auton_drive_functions.cpp), with no real structure to anything.  The code worked, and because this was originally intended for only me to use I felt this was fine.  As more people used it, more errors were caught and it was clunky for users to update the library.  \\r\\n\\r\\nThe code needed to be cleaned and it had to be easier for users to update the library.\\r\\n\\r\\n## [v2.x](https://github.com/EZ-Robotics/EZ-Template/tree/c4a5fd048f90363cc3f841abcb05c95eec2d36c3)\\r\\n### About\\r\\nThis was a complete rewrite of EZ-Template taking advantage of [PROS templates](https://pros.cs.purdue.edu/v5/cli/conductor.html), done with the help of a group of students.  Setup was now done in a constructor and an example project comes loaded with comments and autonomous routines for users to test and play with how the library works.  \\r\\n\\r\\n### Features\\r\\n- SD card saving \\r\\n- \\"tug of war\\" detection in autonomous\\r\\n- PID exits for when drive motors overheat\\r\\n- right stick arcade\\r\\n- loading animation during IMU calibration\\r\\n- 3 wire / smart encoder encoder support\\r\\n- add/remove motors from the drive dynamically if a team uses a PTO\\r\\n- exposed PID class \\r\\n- classed away autonomous selector that is easier to use\\r\\n\\r\\n### Issues\\r\\nMy biggest problem with v1.x and v2.x of EZ-Template is they are *too* easy.  EZ-Template comes with PID and exit condition constants that I tuned for some of my robots.  They were working pretty well within my similar robots, but I assumed everyone would have to tune their own PID because of variances in their robots to mine.  Throughout a few seasons, this assumption has been proven very wrong.  The average team has to do little to no tuning to get consistent results, and that isn\'t my goal with EZ-Template.  The next version of EZ-Template will need to find a way to solve this.\\r\\n\\r\\n## [v3.x](https://github.com/EZ-Robotics/EZ-Template)\\r\\n### About\\r\\nThis version needs to solve the pre-tuned PID values.  The obvious solution to the problem is to not ship EZ-Template with pre-tuned constants but leave everything else the same.  Teams will know to copy/paste old constants, and my problem isn\'t solved. \\r\\n\\r\\nEZ-Template uses a base unit of \\"ticks\\".  One tick means different things depending on the gear ratio of the drive, wheel size, motor cartridge, and what encoder they are using.  This means if a team wanted to switch from using the motor\'s built-in encoders to tracking wheels, they would have to completely retune everything. \\r\\n\\r\\nThis version of EZ-Template will solve this problem by using a base unit of inches.  No matter what sensor the user has, the code will always use inches.  This adds clarity for users by giving units, makes it so users can switch from built-in encoders to tracking wheels and keep the same constants, and stops forward/reverse v2 constants from working in v3.  \\r\\n<Tabs\\r\\n  groupId=\\"ex1\\"\\r\\n  defaultValue=\\"v2\\"\\r\\n  values={[\\r\\n    { label: \'v2.x\',  value: \'v2\', },\\r\\n    { label: \'v3.x\',  value: \'v3\', },\\r\\n  ]\\r\\n}>\\r\\n\\r\\n<TabItem value=\\"v2\\">\\r\\n\\r\\n```cpp\\r\\n  chassis.set_drive_pid(24, DRIVE_SPEED);\\r\\n  chassis.wait_drive();\\r\\n\\r\\n  chassis.set_turn_pid(45, TURN_SPEED);\\r\\n  chassis.wait_drive();\\r\\n```\\r\\n\\r\\n</TabItem>\\r\\n\\r\\n\\r\\n<TabItem value=\\"v3\\">\\r\\n\\r\\n```cpp\\r\\n  chassis.pid_drive_set(24_in, DRIVE_SPEED);\\r\\n  chassis.pid_wait();\\r\\n\\r\\n  chassis.pid_turn_set(45_deg, TURN_SPEED);\\r\\n  chassis.pid_wait();\\r\\n```\\r\\n\\r\\n\\r\\n\\r\\n</TabItem>\\r\\n</Tabs>\\r\\n\\r\\n3.x of EZ-Template will also include a complete redo of all function names.  Function names previously were made by what made the most sense to me.  Need to set the drive to move using PID?  `.set_drive_pid`.  This makes sense in English, but while I was working with [LVGL](https://lvgl.io/) I realized the benefit of naming in order of what you\'re looking for.  So now it\'d be `.pid_drive_set`.  If you\'re looking to see everything you can do with PID on the drive, if you type `.pid_drive_` autocomplete will show you everything you can modify with the drive\'s PID.  This makes autocomplete a powerful tool when you don\'t know everything you can do in the library.\\r\\n\\r\\n### Features\\r\\n- renamed functions\\r\\n- a relative turn function so it\'s not always absolute\\r\\n- a relative swing function so it\'s not always absolute\\r\\n- slew for turns and swings\\r\\n- heading correction now uses vector scaling\\r\\n- swing turns can move in different diameters\\r\\n- add piston class\\r\\n- practice mode for driving\\r\\n- runtime pid tuner for ease of use\\r\\n- [okapi units](https://okapilib.github.io/OkapiLib/md_docs_api_units.html) (so you can now use cm, in, meters, tiles, etc.)"},{"id":"pvc-bipod","metadata":{"permalink":"/projects/pvc-bipod","source":"@site/projects/2024-01-14-pvc-bipod/index.md","title":"PVC Bipod","description":"I designed, manufactured, and assembled PVC bipods for live streaming a VEX tournament.","date":"2024-01-14T00:00:00.000Z","formattedDate":"January 14, 2024","tags":[{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"cad","permalink":"/projects/tags/cad"},{"label":"open source","permalink":"/projects/tags/open-source"}],"readingTime":2.9066666666666667,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"pvc-bipod","title":"PVC Bipod","authors":["jess"],"tags":["hardware","cad","open source"]},"unlisted":false,"prevItem":{"title":"EZ-Template","permalink":"/projects/about-ez-template"},"nextItem":{"title":"Adaptive PID","permalink":"/projects/adaptive-pid"}},"content":"I designed, manufactured, and assembled PVC bipods for live streaming a VEX tournament. \\r\\n\\r\\n![](me_with_tripod.jpg)\\r\\n\\r\\n\x3c!--truncate--\x3e \\r\\n## Design\\r\\n\\r\\nFor this bipod, I want the maximum height to be around 10ft.  Traditional bipods and tripods are more expensive as they\'re designed to carry larger weights than a webcam.  There are many designs online, but none of them are adjustable and I\'d like that to be a requirement for this.  \\r\\n\\r\\nTo keep the two stages together, I\'d need to design something similar to a shaft collar.  Some clamp around the shaft, and some dig a screw into the shaft to prevent movement. \\r\\n![](shaft_collars.png)\\r\\n\\r\\nSome research later, I stumbled across a product that\'s called a \\"telescoping tube clamp\\".  This is exactly what I want, but I don\'t want to spend money on it so I\'ll be designing my version of this. \\r\\n![](telescoping_tube_clamp.png)\\r\\n\\r\\nThe first version of this is a coupler between two PVC sizes.  There\'s a hole between a slit so when a screw gets tightened, the entire thing will squeeze around the PVC.  I\'m concerned this might not have enough grip to hold the pipe in place, this could be fixed with some modified geometry or with some rubber lined on the inside.  The slit also might not come down far enough to allow for enough flex, but that can be fixed by increasing the length of the slit or by making the top portion taller.  For the screw, I\'ll try to find wing screws and wing nuts so this can all be adjusted without tools. \\r\\n![](v1.png)\\r\\n\\r\\nThe base of the structure for this will be a triple PVC connector.  I tried to find one at my local hardware store but couldn\'t for the 1 1/4\\" PVC I\'m using for this, so I have to 3D print it. \\r\\n![](base_tri_mount.png)\\r\\n\\r\\nTo make sure the main pole gets as much support as possible, this goes all the way down to the bottom of the print.  The parts that hold the legs can be slightly weaker because they get a triangle brace to support them.  \\r\\n![](base_tri_mount_half.png)\\r\\n\\r\\nI designed a gusset to triangle brace the base stage of the telescope.  This is a 45-degree angle, only because it makes this much easier to install by having 1 unique part.  If this angle isn\'t enough, I can design 2 brackets to accomplish that.\\r\\n![](45deg_front.png)\\r\\n![](45deg_back.png)\\r\\n\\r\\nAfter sitting on it for a bit, I iterated on this design to use less material for the triangle brace.  This was made by revolving a cylinder and then lofting the face of the rectangle to the tip of the cylinder.  I added some screw holes so I have the option to mechanically link everything together. \\r\\n![](updated_triangle_front.png)\\r\\n![](updated_triangle_back.png)\\r\\n\\r\\nThe most complex part of this is the gusset that meets up with the triangle braces.  This has to be similar to the base mount shown above, but the \\"legs\\" (triangle supports) are all at 45-degree angles to the main pole.  This part ties the structure together.  \\r\\n![](top_tri.png)\\r\\n\\r\\nThe main hole on this is hollow so it can sit where it needs to on the main pipe.  This can be slid up and down to make sure the entire structure is square.  \\r\\n![](top_tri_bot.png)\\r\\n\\r\\nThe inside geometry of this part is very similar to the base structure.  The triangles don\'t come through to the main pipe, and this will get supported through the triangle too. \\r\\n![](top_tri_half.png)\\r\\n\\r\\nThis completes the base triangle.  I might have to add another member between the legs, but hopefully, sandbags on top of the legs will solve that.  I can add this if needed once it\'s assembled.  \\r\\n![](completed_base_structure.png)\\r\\n\\r\\nI messed with some parameters for the telescoping mount and made it wider to fit the PVC and longer to have more contact with everything.  This fits in with the CAD.  \\r\\n![](telescope_mounted_v2.png)\\r\\n\\r\\nOur [Logitech C920](https://a.co/d/dyE8HOH) cameras already have some articulation in them, so for the camera mount I have just one 1/4-20 hole to secure the camera, which also has mounting holes to ensure the camera doesn\'t fall off.  We quickly found out that our cameras did not articulate as much as we anticipated, and we\'ll have to make the camera mount articulate too.  \\r\\n![](camera_mount_v1.png)\\r\\n\\r\\nThe articulating version of the camera mount is extremely similar to the non-articulating one.  This splits the design in two and adds a screw for the part the camera goes to to pivot up and down.  The screw can be tightened for it to stop moving, or it can be pre-tightened to have some friction.  \\r\\n![](articulating_camera_mount.png)\\r\\n\\r\\n## Manufacturing \\r\\nI printed everything with 4 walls and 15% gyroid infill.  I\'ve noticed walls do significantly more for strength than infill.  \\r\\n![](camera_prints.jpg)\\r\\n\\r\\n## Completed Bipods\\r\\nThe bipods were very easy to assemble and I had two of them cut and put together in under 30 minutes.  These were then set up in front of each competition field at Supernova Spectacular to host the live stream, and they worked great!\\r\\n![](final_setup.jpg)\\r\\n\\r\\nThis is just a cool picture of me explaining the rules to competitors with my bipod in the background.  \\r\\n![](me_with_tripod.jpg)\\r\\n\\r\\nSince the conclusion of our event, the bipods have moved to their final home in the robotics lab for The Science Academy and will be used to record scrimmages so students can review matches."},{"id":"adaptive-pid","metadata":{"permalink":"/projects/adaptive-pid","source":"@site/projects/2023-11-22-adaptive-pid/index.md","title":"Adaptive PID","description":"Adaptive PID is a modification of PID that scales constants based on the robot\'s tested velocity curve.","date":"2023-11-22T00:00:00.000Z","formattedDate":"November 22, 2023","tags":[{"label":"software","permalink":"/projects/tags/software"},{"label":"vex","permalink":"/projects/tags/vex"},{"label":"wip","permalink":"/projects/tags/wip"}],"readingTime":3.9233333333333333,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"adaptive-pid","title":"Adaptive PID","authors":["jess"],"tags":["software","vex","wip"]},"unlisted":false,"prevItem":{"title":"PVC Bipod","permalink":"/projects/pvc-bipod"},"nextItem":{"title":"Spraypaint Booth","permalink":"/projects/spraypaint-booth"}},"content":"Adaptive PID is a modification of PID that scales constants based on the robot\'s tested velocity curve.\\r\\n\\r\\n![](banner.png)\\r\\n\\r\\n\x3c!--truncate--\x3e \\r\\n---\\r\\n## About\\r\\nWhen a robot is moving it generates momentum.  PID is extremely consistent when the momentum of the system is constant.  \\r\\n\\r\\nWhen tuning constants for moving, I always notice that after ~2\' of movement the robot is extremely consistent.  In the closer distances, the constants aren\'t quite right, because the momentum is different from when it\'s going full speed.  This is an even larger problem with turns, as the robot never reaches a constant momentum.  \\r\\n\\r\\nA solution I want to avoid is tuning PID constants for multiple turn amounts and interpolating between them.  I haven\'t tested this, but I\'m extremely confident this would be the best solution.  I do not like how much time this takes to set up and tune for each new robot.  My goal is to find a lazier solution that gets almost all of the way there. \\r\\n\\r\\n## EZ-Templates Implemented Solution\\r\\nI had this problem when I was a competitor, and my solution was to:\\r\\n- not run turns as fast as I could, at ~70% power\\r\\n- slow down the robot within some band of the target \\r\\n\\r\\nThis allowed me to have 1 tuned constant and the robot would slow down early for larger movements making everything more similar than without this.  It isn\'t a perfect solution though, it has all of the same problems as not having it but less.  \\r\\n\\r\\n## Detecting When Speed Drops\\r\\nThe first thing I tried was to find 2 parameters: what was the max power being sent to the motors and for how long?  I\'d keep track of all of this during the turn, and when the power started to go down I recognized that as my stopping point.  Now I have these two numbers and I use them to modify all of my PID constants.  \\r\\n\\r\\nThis would sometimes look promising but overall it felt like I needed to tune how much pull/push the two parameters gave to the PID constants for different distances, which defeats the purpose of what I\'m trying to do. \\r\\n```cpp\\r\\nvoid time_full_speed() {\\r\\n  default_constants();\\r\\n  pros::delay(50);\\r\\n  int time_passed = 50;\\r\\n  int i = 0;\\r\\n  std::vector<int> last_power = chassis.drive_get();\\r\\n  std::vector<int> all_powers;\\r\\n  while (true) {\\r\\n    pros::delay(ez::util::DELAY_TIME);\\r\\n    time_passed += ez::util::DELAY_TIME;\\r\\n    printf(\\"%i:   %i != %i\\\\n\\", time_passed, chassis.drive_get()[0], last_power[0]);\\r\\n\\r\\n    int error = abs(chassis.drive_get()[0]) - abs(last_power[0]);\\r\\n    all_powers.push_back(abs(chassis.drive_get()[0]));\\r\\n\\r\\n    if (error < -1) {\\r\\n      i++;\\r\\n    } else {\\r\\n      i = 0;\\r\\n    }\\r\\n\\r\\n    if (i >= 3) {\\r\\n      printf(\\"%i\\\\n\\\\n\\\\n\\", time_passed);\\r\\n      break;\\r\\n    }\\r\\n\\r\\n    last_power = chassis.drive_get();\\r\\n  }\\r\\n  double average_power = 0.0;\\r\\n  for (auto i : all_powers) {\\r\\n    average_power += i;\\r\\n  }\\r\\n  average_power /= all_powers.size();\\r\\n  double time_conversion = (360.0 / (double)time_passed);\\r\\n  double speed_conversion = 80.0 / average_power;\\r\\n  auto consts = chassis.pid_turn_constants_get();\\r\\n  double conversion = (time_conversion) + (speed_conversion);\\r\\n  double max = 1.75;\\r\\n  // conversion = conversion > max ? max : conversion;\\r\\n  conversion = conversion < 1 ? 1 : conversion;\\r\\n  // consts.kp = consts.kp * conversion;\\r\\n  // consts.kd = consts.kd * conversion;\\r\\n  consts.start_i = consts.start_i / conversion;\\r\\n  chassis.turnPID.integral = 0;\\r\\n  chassis.pid_turn_min_set(chassis.pid_turn_min_get() / (conversion * 1.5));\\r\\n  // chassis.pid_speed_max_set(chassis.pid_speed_max_get() / conversion);\\r\\n  chassis.pid_turn_constants_set(consts.kp, consts.ki, consts.kd, consts.start_i);\\r\\n  printf(\\"Time Passed: %i  Last Power: %i Average Power: %.2f    \\\\nTime Conversion: %.2f  Speed Conversion: %.2f  Conversion: %.2f   \\\\nkP: %.2f  kD: %.2f  start i: %.0f  min: %i  max: %i\\\\n\\", time_passed, last_power[0], average_power, time_conversion, speed_conversion, conversion, consts.kp, consts.kd, consts.start_i, chassis.pid_turn_min_get(), chassis.pid_speed_max_get());\\r\\n}\\r\\n\\r\\nvoid turning_test() {\\r\\n  chassis.pid_turn_set(90_deg, TURN_SPEED);\\r\\n  time_full_speed();\\r\\n  chassis.pid_wait();\\r\\n}\\r\\n```\\r\\n\\r\\n## Moving Target with Motion Profiling\\r\\nI took the motion profile test I made for Captain R3X and implemented it here.  This works in the same way it would with a servo, where it sets new target positions for the PID to reach and the rate of change of new targets is being controlled.  This seemed promising, but because I\'m not controlling velocity this wasn\'t working too well.  The robot would move nicely until the end of the motion where the robot would reach its target and stop, then go to the next target, etc.  The robot was stuttering through the end of the motion.  \\r\\n\\r\\n## Acceleration Test\\r\\nI keep thinking back to [TrueSpeed](https://www.vexforum.com/t/24cs-motor-control-value-remapping/23959/1), a fix for VEX\'s motor controllers that weren\'t linear.  The values were remapped and normalized giving a linear output through a LUT (look-up table).\\r\\n\\r\\nI tried something similar.  I told the robot to go at some speed and read the rate of change of the IMU.  After some target degree was passed I stopped reading velocity.  This was done for 17 different target values, running each test 6 times, 3 left and 3 right.  \\r\\n\\r\\nAll of that gave me this graph.  The x-axis is the target we were reading to, and the y-axis is the average velocity in the time it took to get there. \\r\\n![](banner.png)\\r\\n\\r\\nTo use this graph I scaled the Y axis down to 1 by dividing everything by the largest tested Y point.  That left me with many points I can draw lines through and find new conversion rates for untested turn amounts.  I took my conversion rate and I changed my constants by that.  And... it worked!\\r\\n\\r\\nIn this test, the first set of turns is the standard EZ-Template.  The second set of turns is using the modified constants. \\r\\n<iframe width=\\"315\\" height=\\"560\\"\\r\\nsrc=\\"https://youtube.com/embed/qdRAPPe5oj8?si=n4ZuJxHNptZo0IWk\\"\\r\\ntitle=\\"YouTube video player\\"\\r\\nframeborder=\\"0\\"\\r\\nallow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\"\\r\\nallowfullscreen></iframe>\\r\\n\\r\\n```cpp\\r\\nstd::vector<std::vector<double>> scaling = {\\r\\n    {0, 0},\\r\\n    {2.5, 0.09400453473},\\r\\n    {7.5, 0.2022555992},\\r\\n    {12.5, 0.2646745481},\\r\\n    {17.5, 0.3548182873},\\r\\n    {22.5, 0.3951412327},\\r\\n    {27.5, 0.4499251424},\\r\\n    {42.5, 0.5630226236},\\r\\n    {57.5, 0.6381967848},\\r\\n    {72.5, 0.6967510482},\\r\\n    {87.5, 0.7629670943},\\r\\n    {102.5, 0.7982267571},\\r\\n    {117.5, 0.8649159207},\\r\\n    {132.5, 0.8999937274},\\r\\n    {147.5, 0.9429511551},\\r\\n    {162.5, 0.976136005},\\r\\n    {177.5, 1},\\r\\n};\\r\\n\\r\\ndouble get_scale(double target) {\\r\\n  // Find a point that is larger than then target\\r\\n  double initial_error = target - chassis.turnPID.target_get();\\r\\n  initial_error = fabs(initial_error);\\r\\n  int i = 0;\\r\\n  for (auto j : scaling) {\\r\\n    if (j[0] >= fabs(initial_error)) \\r\\n      break;\\r\\n    i++;\\r\\n  }\\r\\n\\r\\n  // If target is equal to or larger than our largest tested point, return 1.0\\r\\n  if (i == scaling.size())\\r\\n    return 1.0;\\r\\n  // If target is equal to or smaller than our smallest tested point, return the smallest conversion\\r\\n  else if (initial_error == scaling[i][0])\\r\\n    return scaling[i][1];\\r\\n\\r\\n  // Draw lines between each point\\r\\n  double m = (scaling[i][1] - scaling[i - 1][1]) / (scaling[i][0] - scaling[i - 1][0]);  // (y2-y1) / (x2-x1)\\r\\n  double b = scaling[i][1] - (m * scaling[i][0]);                                        // b = y - mx\\r\\n  double y = (m * initial_error) + b;                                                    // y = mx + b\\r\\n\\r\\n  return y;\\r\\n}\\r\\n\\r\\nvoid smooth-turn(okapi::QAngle p_target, int speed) {\\r\\n  default_constants();\\r\\n  double conversion = get_scale(p_target.convert(okapi::degree));\\r\\n  auto consts = chassis.pid_turn_constants_get();\\r\\n  consts.kp = consts.kp * conversion;\\r\\n  consts.kd = consts.kd * conversion;\\r\\n  consts.ki = consts.ki * conversion;\\r\\n  consts.start_i = consts.start_i * conversion;\\r\\n  chassis.pid_turn_constants_set(consts.kp, consts.ki, consts.kd, consts.start_i);\\r\\n  printf(\\"\\\\nConversion: %.2f   kP: %.2f  kD: %.2f  start i: %.0f  min: %i  max: %i\\\\n\\", conversion, consts.kp, consts.kd, consts.start_i, chassis.pid_turn_min_get(), chassis.pid_speed_max_get());\\r\\n\\r\\n  chassis.pid_turn_set(p_target, speed);\\r\\n}\\r\\n```\\r\\n\\r\\nIn the tests for the data that was collected, the speed that the robot was going at is constant.  A potential improvement is to allow multiple tests with multiple speeds and make a 3D graph to find new scaling values.  At some point, this defeats the purpose of being easier than the alternative though."},{"id":"spraypaint-booth","metadata":{"permalink":"/projects/spraypaint-booth","source":"@site/projects/2023-10-23-spraypaint-booth/index.md","title":"Spraypaint Booth","description":"I built a ventilated box to spray paint indoors.","date":"2023-10-23T00:00:00.000Z","formattedDate":"October 23, 2023","tags":[{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"cad","permalink":"/projects/tags/cad"},{"label":"electrical","permalink":"/projects/tags/electrical"},{"label":"wip","permalink":"/projects/tags/wip"}],"readingTime":1.57,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"spraypaint-booth","title":"Spraypaint Booth","authors":["jess"],"tags":["hardware","cad","electrical","wip"]},"unlisted":false,"prevItem":{"title":"Adaptive PID","permalink":"/projects/adaptive-pid"},"nextItem":{"title":"French Cleats","permalink":"/projects/french-cleats"}},"content":"I built a ventilated box to spray paint indoors.\\r\\n![](banner.png)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n---\\r\\n\\r\\nFor DD-3 I was spray painting so much that I needed a better solution for it.  I saw online that people had little booths to spray paint and airbrush in.  I looked to buy one and they were ~$70 for the cheapest one I could find and it was tiny, and larger ones couldn\'t fold up for storage.  I decided to make my own.  \\r\\n\\r\\nI had some aluminum 1/2\\" angle and decided that I\'d build it all out of that.  I want to comfortably fit an R2 dome inside, so this needs to be at least 18\\".  I like having more room on the bottom for laying out parts, and after playing with some lengths on my workbench I decided on 30\\" wide and 24\\" deep.  Deciding height was trickier, the fan is more effective the smaller the volume of the box is.  Ultimately I decided the back top edge wasn\'t going to be useful space, so the back of the box was going to be 18\\" and the front 26\\".  \\r\\n![](side24.png)\\r\\n![](side18.png)\\r\\n\\r\\nI designed 3D-printed brackets to connect all of the angles.  The small back rectangle is being treated as the main box, and everything is pivoting around that for fold-up.  \\r\\n![](no-support.png)\\r\\n\\r\\nI added diagonals to stop everything from collapsing, and that\'s the design done.  The back rectangle has enough space for a fan and filter to be added, I will figure that out when I get there. \\r\\n![](banner.png)\\r\\n\\r\\nAssembly all worked out like in CAD.  For the fan, I\'m using the cheapest bathroom exhaust fan Home Depot had, rated for 50 cubic feet per minute which is much larger than the volume of this booth. An air filter gets press-fit over that, and the exhaust fan goes directly out my window.   \\r\\n![](first_assemble.jpg)\\r\\n\\r\\nTo fill in the sides I was originally going to use cardboard, but I wanted a replaceable surface on the inside so when it got gross with paint I could have a fresh surface.  I tried forgoing the cardboard entirely and just gift-wrapping the box in thin plastic, which was functional but looked awful and was harder to replace than if I had cardboard.  With cardboard walls, I can just tape the plastic over the inside.  To replace this, I have to remove the booth from my desk and roll it around in plastic.  It also looks bad.  But this is a tool for me to complete another project, so I will fix that another day.\\r\\n![](gift_wrapped.jpg)\\r\\n\\r\\nThe lighting inside the box was horrible, so I got a small garage light and mounted it to the front. \\r\\n![](garage_light.jpg)\\r\\n\\r\\nMy next steps are to:\\r\\n- add cardboard walls\\r\\n- add an on/off switch for the exhaust\\r\\n- wire the light and exhaust to a single cable"},{"id":"french-cleats","metadata":{"permalink":"/projects/french-cleats","source":"@site/projects/2023-07-05-french-cleats/index.md","title":"French Cleats","description":"I designed and built French cleats for storing tools on my wall.","date":"2023-07-05T00:00:00.000Z","formattedDate":"July 5, 2023","tags":[{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"cad","permalink":"/projects/tags/cad"},{"label":"wip","permalink":"/projects/tags/wip"}],"readingTime":1.81,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"french-cleats","title":"French Cleats","authors":["jess"],"tags":["hardware","cad","wip"]},"unlisted":false,"prevItem":{"title":"Spraypaint Booth","permalink":"/projects/spraypaint-booth"},"nextItem":{"title":"The Pushbot","permalink":"/projects/the-pushbot"}},"content":"I designed and built French cleats for storing tools on my wall.\\r\\n\\r\\n![](banner.jpg)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n---\\r\\n\\r\\nIt was becoming impossible to work on any project without my working surfaces covered in tools.  The tools have homes, but they are in drawers or not close to where I\'m working.  I need a 1 step solution to store things I use often, and I\'m going to use my wall for that. \\r\\n\\r\\nI don\'t think pegboards look very good (and are strangely expensive), and currently I sleep in the room I make things in so that matters to me.  I discovered what French cleats were through [Hank Green](https://youtu.be/KIqs4zIovTk?si=GSH6dp7U7DM5r2E4&t=178) in his office tour.  I remembered seeing them somewhere else and found it\'s a common enough workshop storage solution.  I found options for things complete systems I could buy but they were all so expensive.  I priced everything out to be significantly cheaper through McMaster, and even cheaper when I went to pick it up instead of paying for shipping. \\r\\n\\r\\nInstead of machining a 45-degree angle into metal which I don\'t have the tools for, I decided on leaving a gap between the wall and a piece of metal.  There will be a piece of plastic between them.  This lets me have a matching shape on something I mount to the wall.  \\r\\n![](cleat_cad.png)\\r\\n\\r\\nI mounted the plastic and aluminum to my wall after making sure I was hitting studs and everything was level, and started work on a drill mount. I have a piece of plastic going inside the gap between the aluminum and my wall, and I\'m using 1/2\\" angle to make the holder for the drill. \\r\\n![](drill_started.jpg)\\r\\n\\r\\nI free-handed the design and hole placement but it came out working nicely.  \\r\\n![](drill_done.jpg)\\r\\n\\r\\nI designed caliper holders and a mount for a paper towel holder.  (yes the tape isn\'t level, my marker lines are level though)\\r\\n![](caliper.jpg)\\r\\n\\r\\nIt\'s a lot of work to design a custom holder for everything I want on the wall.  Of course, some things will need to be custom, but in general, I\'d like to try to use some generic hook design.\\r\\n![](big_hook_cad.png)\\r\\n\\r\\nWith this as a base, it\'s much easier to add modifications to it.  This is much nicer than making a custom holder for every part. \\r\\n![](hot_glue_gun_holder.jpg)\\r\\n![](ipa.jpg)\\r\\n\\r\\nI took my drill bit case took out each section, and made simple brackets for them to go on the wall with.  \\r\\n![](drill_index.png)\\r\\n![](drill_index_wall.jpg)\\r\\n\\r\\nI tried to make a hexagonal little crate to hold markers and maybe pens but it ended up looking really ugly because of the amount of wasted space.  I changed the design for a strip of poly spaced out from the wall acting like a belt and this works and looks much better.\\r\\n![](marker1.jpg)\\r\\n![](marker2.jpg)\\r\\n\\r\\nI mounted more aluminum to my wall near my workbench and have homes for tools I use often there.  I bought a Milwaukee screwdriver holder for their pack-out system, but just drilled holes in it and mounted a bit of aluminum to go around the French cleat.  I used one of the generic hooks to hold pliers and snips.\\r\\n![](workbench1.jpg)\\r\\n\\r\\nNext, I need to find homes for:\\r\\n- sandpaper\\r\\n- spray paint\\r\\n- Bondo\\r\\n- tape\\r\\n- spray paint\\r\\n- dremel and dremel bits\\r\\n- dykem"},{"id":"the-pushbot","metadata":{"permalink":"/projects/the-pushbot","source":"@site/projects/2023-02-17-the-pushbot/index.md","title":"The Pushbot","description":"The Pushbot is a simple robot to demonstrate how strategy can get baked into a robot\'s design for the VRC game Spin Up.","date":"2023-02-17T00:00:00.000Z","formattedDate":"February 17, 2023","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"software","permalink":"/projects/tags/software"},{"label":"cad","permalink":"/projects/tags/cad"}],"readingTime":5.1466666666666665,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"the-pushbot","title":"The Pushbot","authors":["jess"],"tags":["vex","hardware","software","cad"]},"unlisted":false,"prevItem":{"title":"French Cleats","permalink":"/projects/french-cleats"},"nextItem":{"title":"Supernova Spectacular Awards","permalink":"/projects/supernova-spectacular-awards"}},"content":"The Pushbot is a simple robot to demonstrate how strategy can get baked into a robot\'s design for the VRC game Spin Up.\\r\\n\\r\\n![](banner.png)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n---\\r\\n\\r\\n## About\\r\\nThe goal of this robot was to make a robot without a shooter to be as competitive as possible for the VRC game Spin Up.  Students liked the idea of this, so they helped create a list of constraints that my robot needed to have:\\r\\n- no intake\\r\\n- no shooter\\r\\n- block others from shooting discs\\r\\n- block others from shooting expansive\\r\\n- anti wedges and wedges\\r\\n- needs to spin rollers\\r\\n- follows VEXU rules (8 motor drive)\\r\\n- eat all the discs from the center line during autonomous\\r\\n- molded traction wheel\\r\\n\\r\\n## Design\\r\\nTo block shots, we had an idea that we were calling a windmill.  This beautiful image made by \\"CAD\\" was made to showcase how the structure will work on this robot.  With two intersecting diagonals, the structure for a roller and the windmill support each other.  This all requires a sturdy enough drive train.\\r\\n![](windmill_og_cad.png)\\r\\n\\r\\nWhen I was competing in Change Up, I made a drive base that used a 1/4\\" piece of 6061 aluminum for the main structure and had a piece of 1/16\\" sheet at the front.  I didn\'t realize at the time how overkill this bracing was, but this gave me confidence in making an extremely sturdy drivetrain with nothing but a 1/16\\" aluminum sheet. \\r\\n\\r\\nThis is my first draft of figuring out where everything will go.  I generated gears for the drive to let my 3.25\\" wheels go 510rpm, which has the robot moving at ~86\\"/s.  The drive channels are 1\\" square tubes that I\'ll bandsaw down the middle  The top and bottom plates are 1/16\\" aluminum that I\'ll order from Send cut Send.\\r\\n![](1stdrive.png)\\r\\n\\r\\nWith how tall the motors are it needed some brace to stop the entire thing from bending backwards.  I added a triangle brace to the side of them and added in the gears that the top 2 motors will be spinning.  I\'ll need to make a plate to support the other end of those shafts later.\\r\\n![](first_triangle.png)\\r\\n\\r\\nI added diagonals for the windmill and the roller mechanism.  The roller will be a 3\\" flex wheel spinning at 50rpm.  The windmill is a thin piece of nylon tube I found on McMaster, this will be very light and easy to spin up fast to block people from shooting discs.\\r\\n![](windmill_size.png)\\r\\n![](roller_and_windmill_strutcure.png)\\r\\n\\r\\nI designed a hub for the flex wheels where a 1/4\\" ID bushing would sit.  This would spin on a round standoff.  To interface the gear with the mechanism I have interlocking geometry between the gear and the flex wheel hub so the force gets distributed nicer.\\r\\n![](flexwheel_mount.png)\\r\\n![](roller_gear.png)\\r\\n\\r\\nI\'m using a 100rpm motor geared down 2:1 so the roller spins at 50rpm.  The idler gear is spinning on a round standoff that is also being used to mount the motor.\\r\\n![](roller_assembly.png)\\r\\n\\r\\nI designed a hub to hold 1/4\\" ID bushings for the tube, and I have the same interlocking geometry between the gear and the tube.  This is geared 1:1 and will use a 600rpm motor.\\r\\n![](windmill_gearbox.png)\\r\\n\\r\\nA problem the windmill has is expansion.  A robot cannot be larger than 18\\" when entering the low zone, and this is larger than 18\\" unless it\'s parallel to the ground.  To solve this I\'m adding a ratchet so that when the motor spins backward the windmill will sit in a position where it\'s not larger than 18\\".\\r\\n\\r\\nThe pink pawl will be rubber banded to click into the ratchet.  When the windmill spins in one direction, the pawl will slop and this will be allowed to spin.  When the motor spins in the opposite direction, the pawl will engage the ratchet and this will sit in size.\\r\\n![](ratchet.png)\\r\\n\\r\\nThis robot will be doing a lot of pushing and I need to make sure nothing on the drive breaks.  For the gears on the omni wheels, I copied the spoke pattern in VEX\'s 3.25\\" wheel so this gear interlocks with the wheel.  All of the force will get distributed across the print, and screws will be used just to keep it from falling out. \\r\\n![](wheel_gear.png)\\r\\n![](omni_wheel_and_gear.png)\\r\\n\\r\\nThe molded traction wheel gets little T\'s around it so the rubber will have a harder time falling off.  There are also pools of open space around some of the T\'s to hopefully stop the rubber from peeling off.  This is similar to how I\'ve made molded wheels before, so I feel confident this will have no problems.  \\r\\n![](traction_core.png)\\r\\n\\r\\nThe wheel also gets pocketing so a gear can interlock with it.\\r\\n![](traction_wheel_and_gear.png)\\r\\n\\r\\nI made a part to support the motor shafts.  It screws into the motor gap and gets a lower mounting point that has a standoff going to the outer drive channel.  It can\'t go to the inner drive channel because the gear is in the way.\\r\\n![](motor_shaft_support.png)\\r\\n\\r\\nI also changed up the motor mount triangle support to be in the center to give some more space on the outside.\\r\\n![](motor_cap_with_triangle.png)\\r\\n\\r\\nFor the plow to take all of the discs off of the center line, I needed a pneumatic tank.  I made space for one in the center and made cutouts for the tank in the drive bracing.\\r\\n![](tank_mount.png)\\r\\n\\r\\nBecause pushing discs with a flat surface isn\'t possession, I made the front of the robot able to turn into an angle.  This is still a flat surface, and when I drive along the center line all of the discs will come to my side of the field.\\r\\n![](plow_cad.png)\\r\\n\\r\\nI used a spare wedge from Change Up and had a simple mount for it.  For everything to be in size, the wedge needed to start up and there\'s a piston to release it with the Star Wars battle droid-looking mechanism. \\r\\n\\r\\nAnd with that, the CAD was done.\\r\\n![](final_cad.png)\\r\\n\\r\\nUltimately we found out it was illegal to use the windmill, so sadly that will not make it into the assembly.\\r\\n\\r\\n## Assembly\\r\\n### Assembling Based on CAD\\r\\nThe aluminum came in from Send Cut Send and looks great.\\r\\n![](alu.jpg)\\r\\n\\r\\nThe tank and motor mounts all fit in nicely.\\r\\n![](with_tank.jpg)\\r\\n\\r\\nI used (too much) dykem blue to drill the holes in the angles and c-channel.  I used calipers (not my nice pair) to scribe lines into the metal, and center punched hole by hole and made new lines based on those holes.  This was my first time doing this and it all went really well, the accuracy on everything is more than enough for what this is. \\r\\n![](dykem.jpg)\\r\\n\\r\\nEverything is coming together very smoothly and as I planned.\\r\\n![](lulu.jpg)\\r\\n![](finished_roller.jpg)\\r\\n\\r\\nThe plow uses zip ties to push discs, these were eventually cut to not touch the floor.  I used zip ties because this needed to be stiff enough to push a disc but flexible enough to allow the robot to go over a ~1\\" barrier, and zip ties accomplished that simply for me.\\r\\n![](eyelash_in.jpg)\\r\\n![](eyelash_out.jpg)\\r\\n\\r\\nI added pivoting pieces of plastic to the side of the robot to stop opponents from being able to push as well.  When they try to push me, they\'ll drive up me and add weight to my robot.  It will still be possible to push but less effective.  These are on hinges to ensure they always touch the ground and are lower than the opponents.  This type of anti-wedge was inspired by the Battle Bots robot Hyrdra.\\r\\n![](anti_wedge.jpg)\\r\\n\\r\\nThe wedge is mounted to lift up opponents a bit when pushing them, which makes this robot functional!\\r\\n![](bot_on_table.jpg)\\r\\n\\r\\nLater I made the traction wheel and got that mounted.\\r\\n![](mounted_traction.jpg)\\r\\n\\r\\n### Lift\\r\\nWith no windmill, I felt like this robot needed a way to block *something*.  What I decided on building was a 6 bar that is rubber banded up and locked to the chassis with a piston.  \\r\\n\\r\\nThe first thing to do is design a mount for the lift to sit on, I made this out of 1/16\\" 6061 and mounted it through the roller.\\r\\n![](first_lift.jpg)\\r\\n\\r\\nBecause the geometry between these bars is strange, I prototyped the shape of the connecting linkage with cardboard.\\r\\n![](middle_linkage.jpg)\\r\\n\\r\\nI made the top linkage out of some 1/16\\" polycarbonate angle I had, and this lift was pretty light and able to lift high enough to block the entire goal (which is illegal, but I can do it!).  This is still using a prototype final linkage though.\\r\\n![](lift_raised.jpg)\\r\\n\\r\\nAnd with a real linkage made for the last vertical, this lift can rise to a height of 51\\".\\r\\n![](lift_with_real_linkages.jpg)\\r\\n\\r\\nI made printed hooks that held onto arms and stopped them from coming out.  When the lift was raised, these arms would extend outwards.  This extra width would allow me to make an expansion blocker that is much wider than I otherwise could.\\r\\n<iframe width=\\"315\\" height=\\"560\\"\\r\\nsrc=\\"https://youtube.com/embed/AdtnW2aCjzA\\"\\r\\ntitle=\\"YouTube video player\\"\\r\\nframeborder=\\"0\\"\\r\\nallow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\"\\r\\nallowfullscreen></iframe>\\r\\n<iframe width=\\"315\\" height=\\"560\\"\\r\\nsrc=\\"https://youtube.com/embed/fhauUic9YH4\\"\\r\\ntitle=\\"YouTube video player\\"\\r\\nframeborder=\\"0\\"\\r\\nallow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\"\\r\\nallowfullscreen></iframe>\\r\\n\\r\\nTo actually block, I used an old bed sheet I had.  It\'s ugly but it works and didn\'t cost anything.\\r\\n<iframe width=\\"315\\" height=\\"560\\"\\r\\nsrc=\\"https://youtube.com/embed/coOcKaicCWo\\"\\r\\ntitle=\\"YouTube video player\\"\\r\\nframeborder=\\"0\\"\\r\\nallow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\"\\r\\nallowfullscreen></iframe>"},{"id":"supernova-spectacular-awards","metadata":{"permalink":"/projects/supernova-spectacular-awards","source":"@site/projects/2022-12-04-supernova-spectacular-awards/index.mdx","title":"Supernova Spectacular Awards","description":"I designed and made 19 custom awards to give out during Supernova Spectacular, our VRC event.","date":"2022-12-04T00:00:00.000Z","formattedDate":"December 4, 2022","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"cad","permalink":"/projects/tags/cad"},{"label":"build log","permalink":"/projects/tags/build-log"}],"readingTime":1.9566666666666668,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"supernova-spectacular-awards","title":"Supernova Spectacular Awards","authors":["jess"],"tags":["vex","hardware","cad","build log"]},"unlisted":false,"prevItem":{"title":"The Pushbot","permalink":"/projects/the-pushbot"},"nextItem":{"title":"Preload Disc Holder","permalink":"/projects/preload-disc-holder"}},"content":"I designed and made 19 custom awards to give out during Supernova Spectacular, our VRC event.  \\r\\n\\r\\n![](excellence.JPG)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n## Design\\r\\nThe event was giving out 9 awards per competition, and we held a Middle School competition on Saturday and a High School competition on Sunday.  This meant I had to make double the amount of awards.  \\r\\n\\r\\nRECF sends some awards for free to give out for your first event.  We could have bought the rest of the trophies from RECF / VEX, but for a similar price, we made custom cooler awards that we felt teams would be happier getting.  I ended up making custom awards for the highest awards (excellence, tournament champion, robot skills) and made my own plaques for the standard VEX trophies.  \\r\\n\\r\\nThe award list to make is:\\r\\n- Excellence x2\\r\\n- Tournament Champion x4\\r\\n- Skills Champion x2\\r\\n- Design x2\\r\\n- Judges x2\\r\\n- Think x2\\r\\n- Build x2\\r\\n- Create x2\\r\\n- Volunteer of the Year x1\\r\\n\\r\\n### Special Awards\\r\\nI did research into how other events made their awards and these two stood out to me the most.  I liked having game elements behind the award, and I liked the aluminum plate for the front.  \\r\\n<img\\r\\n  src={require(\\"./aubie_award.png\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"37%\\", height: \\"auto\\" }}\\r\\n/><img\\r\\n  src={require(\\"./caution_tape_award.png\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"50%\\", height: \\"auto\\" }}\\r\\n/>\\r\\n\\r\\nMy first attempt had the discs purple instead of yellow for supernova colors.  I felt this took away from the point of them being game elements from that year, so I changed the purple to yellow.  This part will be made in 2 parts, one that I change the filament halfway through to get the yellow, and one to go around that and act as a border.  \\r\\n<img\\r\\n  src={require(\\"./purple_disc.png\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"43%\\", height: \\"auto\\" }}\\r\\n/><img\\r\\n  src={require(\\"./yellow.png\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"43%\\", height: \\"auto\\" }}\\r\\n/>\\r\\n\\r\\nWith the back of the part done, I started designing the front.  It needed to say `SUPERNOVA SPECTACULAR`, the name of the award, and the Supernova logo.  This meant for each version of the trophy the only thing I change is the bottom award name.  I made the image below to see if I liked the way this looked, but it is impossible to create like that because of floating material in letters like `O` and the inside of the Supernova logo.  \\r\\n<img\\r\\n  src={require(\\"./impossible_tc_render.png\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"43%\\", height: \\"auto\\" }}\\r\\n/>\\r\\n\\r\\nThis was fixed with some connecting pieces between floating parts.  It changed how the logo looks a bit, but (before I wrote this article about it) no one noticed but me.  \\r\\n<img\\r\\n  src={require(\\"./possible_tc_alu.png\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"43%\\", height: \\"auto\\" }}\\r\\n/>\\r\\n\\r\\n### Plaques \\r\\nWith limited space on the trophy, I couldn\'t fit the Supernova logo on the plaque.  Just putting `SUPERNOVA SPECTACULAR`, and `2022-2023` along with the award name doesn\'t look overcrowded.  \\r\\n<img\\r\\n  src={require(\\"./think_award_plaque.png\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"43%\\", height: \\"auto\\" }}\\r\\n/>\\r\\n\\r\\n## Assembly \\r\\n\\r\\nHere is the final part before fabrication was started.  \\r\\n<img\\r\\n  src={require(\\"./tc-v2.png\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"43%\\", height: \\"auto\\" }}\\r\\n/>\\r\\n\\r\\nI made one to make sure it worked before printing the rest of them.  \\r\\n<img\\r\\n  src={require(\\"./first_done.jpg\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"43%\\", height: \\"auto\\" }}\\r\\n/><img\\r\\n  src={require(\\"./printing_more.jpg\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"43%\\", height: \\"auto\\" }}\\r\\n/>\\r\\n\\r\\nThis is a 2 part assembly, where one is printed with the text and the second is spray-painted purple and put behind the plaque.  \\r\\n<img\\r\\n  src={require(\\"./design.jpg\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"43%\\", height: \\"auto\\" }}\\r\\n/>\\r\\n\\r\\n## Final Results\\r\\n![](final_all.JPG)\\r\\n![](excellence.JPG)\\r\\n![](tournament_champion.JPG)\\r\\n![](double_tc.JPG)"},{"id":"preload-disc-holder","metadata":{"permalink":"/projects/preload-disc-holder","source":"@site/projects/2022-10-27-preload-disc-holder/index.md","title":"Preload Disc Holder","description":"I made disc holders to help run Spin Up tournaments more efficiently.","date":"2022-10-27T00:00:00.000Z","formattedDate":"October 27, 2022","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"hardware","permalink":"/projects/tags/hardware"}],"readingTime":0.5233333333333333,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"preload-disc-holder","title":"Preload Disc Holder","authors":["jess"],"tags":["vex","hardware"]},"unlisted":false,"prevItem":{"title":"Supernova Spectacular Awards","permalink":"/projects/supernova-spectacular-awards"},"nextItem":{"title":"EZ GUI","permalink":"/projects/about-ez-gui"}},"content":"I made [disc holders](https://www.printables.com/model/329950-vex-spin-up-preload-holder) to help run Spin Up tournaments more efficiently.\\r\\n\\r\\n![](banner.jpg)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nIn the VEX game Spin Up, there are 11 discs that stay out of the field per side.  7 are match loads that can be loaded at any time during driver control, and 4 are preloads, 2 per robot.  To help people reset the fields easier, and to help competitors quickly know if they have the correct amount of discs, I made a printable preload holder.  Once the discs are flush with the stems of the print, the team has the correct amount of discs.  \\r\\n\\r\\nThese parts lasted a surprising amount of time given they were printed and were next where high school and middle school students were standing all day.  They lasted around 6 tournaments before they were too broken for use.  They are assembled using standard VEX hardware, 8-32 screws, and 11/32 locknuts.  The files are public for anyone to use."},{"id":"about-ez-gui","metadata":{"permalink":"/projects/about-ez-gui","source":"@site/projects/2022-09-02-ez-gui/index.md","title":"EZ GUI","description":"EZ-GUI is a simple-to-use VEX V5 screen GUI that intuitively keeps track of motor temperatures and allows users to select autonomous routines.","date":"2022-09-02T00:00:00.000Z","formattedDate":"September 2, 2022","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"open source","permalink":"/projects/tags/open-source"},{"label":"software","permalink":"/projects/tags/software"},{"label":"wip","permalink":"/projects/tags/wip"}],"readingTime":0.7933333333333333,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"about-ez-gui","title":"EZ GUI","authors":["jess"],"tags":["vex","open source","software","wip"]},"unlisted":false,"prevItem":{"title":"Preload Disc Holder","permalink":"/projects/preload-disc-holder"},"nextItem":{"title":"EZ Mid","permalink":"/projects/mid"}},"content":"[EZ-GUI](https://github.com/EZ-Robotics/EZ-GUI) is a simple-to-use VEX V5 screen GUI that intuitively keeps track of motor temperatures and allows users to select autonomous routines. \\r\\n\\r\\n![](banner.png)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n## About\\r\\n\\r\\nI\'ve seen other teams with UIs that have many pages and can do a bunch of stuff, but I wanted something simple.  The [LLEMU](https://pros.cs.purdue.edu/v5/tutorials/topical/llemu.html) is great for an autonomous selector but it\'s difficult to implement motor temperature readings. \\r\\n\\r\\nAll of the displayed names for my autonomous routines are short, so I could dedicate a very small portion of the screen to that.  The rest of the screen could be split into a grid and just have a light gray outline to start.  As motor temperatures heat up, the color of the box will increase to eventually be the same color as the left/right buttons for the autonomous selector.  The closer they are in color, the warmer the motors are.  There\'s black text showing the name of the motor as well.\\r\\n\\r\\nI like this method of detecting temperature because under normal use the brain screen shows nothing.  Then as you use the robot more, you\'ll see something catch your eye and it reminds you to slow down / let the robot have a break.\\r\\n\\r\\nThis isn\'t documented or an officially released library yet, but the plan is to eventually set that up.  I\'d like to add different screens as well instead of temperature reading, like a logger or being able to graph stuff."},{"id":"mid","metadata":{"permalink":"/projects/mid","source":"@site/projects/2022-08-22-ez-mid/index.md","title":"EZ Mid","description":"Built with Lucas Wills, Mid was an iteration of a simple robot built by 13186A to demonstrate to students iterating based on others\' designs.","date":"2022-08-22T00:00:00.000Z","formattedDate":"August 22, 2022","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"software","permalink":"/projects/tags/software"},{"label":"cad","permalink":"/projects/tags/cad"},{"label":"spin up","permalink":"/projects/tags/spin-up"}],"readingTime":8.903333333333334,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"mid","title":"EZ Mid","authors":["jess"],"tags":["vex","hardware","software","cad","spin up"]},"unlisted":false,"prevItem":{"title":"EZ GUI","permalink":"/projects/about-ez-gui"},"nextItem":{"title":"Harvard-Westlake- BLZ-i","permalink":"/projects/harvard-westlake-blz-i"}},"content":"Built with Lucas Wills, Mid was an iteration of a [simple robot built by 13186A](https://www.youtube.com/watch?v=CqWtpF6hbSg) to demonstrate to students iterating based on others\' designs.  \\r\\n\\r\\n![](banner.jpg)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n## About\\r\\nUsing 13186A as a base point, Lucas and I designed and iterated the system to get discs from storage to the flywheels.  The design we ended with was a linear slide that pushed the discs through, removing all the slip that the chain had.  I made software that automates the linear slide for the driver, regulates flywheel velocity using PID, jam detection on the intake, and pure pursuit for autonomous.  This robot uses custom molded traction wheels with 20A polyurethane and a custom-made gear ratio that gives 417rpm on 4.125\\" wheels.\\r\\n\\r\\n## Design and Prototyping\\r\\nThis robot needs a way to intake discs without them being launched through the flywheel.  We first wanted to test how far we could push the speed of the design that team 13186A used, so we built something similar.  This structure has rollers underneath the disc so the disc has low friction traveling through.  We started with what we believe 13186A used and built the conveyor to move at 600rpm.  This worked, but would need another mechanism to stop the discs from reaching the flywheel until we wanted them to.  \\r\\n<iframe width=\\"315\\" height=\\"560\\" src=\\"https://www.youtube.com/embed/Izyi3V0yNfA?si=E7BX5xo2wY54dv4v\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>  \\r\\n\\r\\nKeeping the same design, we modified the conveyor to take 2 motors and to be 1200rpm.  \\r\\n![](conveyor_test2_pic.jpg)  \\r\\n\\r\\nThis worked but it wasn\'t twice as fast as the 600rpm.  This is because of an inherent design flaw where the conveyor needs to be able to slip over the discs.  \\r\\n<iframe width=\\"315\\" height=\\"560\\" src=\\"https://www.youtube.com/embed/E3u8rGcTqjo?si=q1DcrXMYRVST1RP-\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\nThe new idea is to have a wheel that pushes the disc past a one-way gate.  This one-way gate would be on a linear slider and would push all 3 discs out at once.  This stops any slip from being able to happen.  Our first test of this was this simple wheel that takes in balls and pulls them past a one-way gate.  This worked amazingly.  \\r\\n![](hook_test1.jpg)\\r\\n![](hook_test2.jpg)\\r\\n\\r\\nI designed a carriage to ride 1/8\\" polycarbonate.  This will use a rack and pinion to power it up.  \\r\\n![](slider2.jpg)\\r\\n![](slider1.jpg)\\r\\n\\r\\nThe first test of the slider is very promising.  We want the speed to be a bit faster, but there is no slipping and this is still able to intake discs.  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/m_KOmR3r13k?si=3pKvPldhBDf3KgX4\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\nThe one-way gate needed to have tension in one direction keeping it open.  Lucas used a piece of 1/32\\" polycarbonate to act as the spring.  This is much smaller, simpler, and more reliable than using rubber bands or latex tubing.  \\r\\n![](poly_spring.jpg)\\r\\n\\r\\nI designed hubs for [30a 4\\" flex wheels](https://www.vexrobotics.com/vrc-flex-wheels.html).  For our prototype, we used the spacing that 13186A used as a starting point.  The space between the flex wheels matters for how much compression there is.  These caps take a [12t high strength pinion](https://www.vexrobotics.com/gears.html) in the center to make it compatible with a vex shaft.  Using a pinion here distributes the force across many points making it a much stronger mechanical connection.  The pinion is press fit using an arbor press.  \\r\\n![](flexwheel_hubs.jpg)\\r\\n\\r\\nLucas and I built the flywheel assembly using the same gear ratio as well, 7:3 with the motors using 600rpm cartridges.  The results were really good.  We tried moving the compression in more and it quickly became too much compression, and if they were any farther apart there would be none.  We kept this flywheel distance.  \\r\\n<iframe width=\\"315\\" height=\\"560\\"\\r\\nsrc=\\"https://www.youtube.com/embed/UFsEGaHEmUo\\"\\r\\ntitle=\\"YouTube video player\\"\\r\\nframeborder=\\"0\\"\\r\\nallow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\"\\r\\nallowfullscreen></iframe>\\r\\n<iframe width=\\"315\\" height=\\"560\\"\\r\\nsrc=\\"https://www.youtube.com/embed/Lj05GJx497g\\"\\r\\ntitle=\\"YouTube video player\\"\\r\\nframeborder=\\"0\\"\\r\\nallow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\"\\r\\nallowfullscreen></iframe>\\r\\n\\r\\nAfter this testing, we felt we were ready to move on and start making the robot.  This drive goes 90\\"/s, we used other drive trains that were 86\\"/s and felt that was a good ballpark to get to.  I couldn\'t make it the same because this drive train uses a different-sized wheel for the center.  The larger 4.125\\" wheels spin at ~420rpm and the smaller 2.75\\" wheel spins at ~630rpm.  I wanted this chassis to fit within 15\\" but I wanted to use 4.125\\" wheels to get over the low zone barrier easier, and this required using multiple sizes of wheel.  I included space behind the back motors to fit tracking wheels.  The cross bars on this robot are 1/2\\" 6061 aluminum angle that I got from McMaster.  \\r\\n![](chassis-cad.png)\\r\\n\\r\\n## Assembly \\r\\nThe chassis needed some holes opened or widened to allow clearance for everything.  The gears that I designed don\'t align with the hole pattern on c-channels sadly.  The gears I designed for the wheels go into the spokes to give a better mechanical connection between the two.  \\r\\n![](half-chassis.jpg)\\r\\n\\r\\nWe built up both sides and I designed gussets to hold the slider.  There are also some holes for shafts to run across for the intake roller.  \\r\\n![](chassis_with_towers.jpg)\\r\\n\\r\\nFor the intake roller, we wanted a shaft to go all the way across both sides around where the towers are above.  To do this we had to shift the motor back and use some gears to get a shaft going all the way across.  \\r\\n![](chassis_with_intake_gears.jpg)\\r\\n\\r\\nThe conveyor was screwed onto the tower mounts, and I designed a triangle brace for the conveyor that uses another piece of angle aluminum, this makes the entire conveyor very strong.\\r\\n![](conveyor_on_chassis.jpg)\\r\\n\\r\\nFor the actual intake, there is a sprocket on the axle that runs across both towers.  A chain will run from that sprocket to the metal sprocket in the video below.  The 3D-printed cylinder will be mounted to a piece of PVC that has rubber over it.  The intake arm pivots around an extruded cylinder from the tower mounts.  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/5m1QFM3KUtY?si=cKwpfGN3Saat7Jj4\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\nWe got the rubber over the pipe by blowing it up with an air compressor and sliding it over the pipe, that entire process was unenjoyable and inefficient.  If I were to do this again, I would use the solvents that are used to replace grip on golf clubs.  \\r\\n![](rubber_tube_compressor.jpg)\\r\\n![](intake_on.jpg)\\r\\n\\r\\nWhile waiting for some prints to finish so we could make the flywheel assembly, I mounted the tracking wheels.  \\r\\n![](tracking_wheel.jpg)\\r\\n\\r\\nWe kept the same wheel spacing as before, but the 7:3 gear ratio we were using previously with VEX gears wasn\'t very nice.  The wheel spacing just barely doesn\'t work with 4 gears total and we would have had to go to 6.  I designed custom gears that have the same 7:3 ratio which let us use just 4 gears.  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/DCpMuIPNv4U?si=qs7nMa_-elB-_3V3\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\nThe flywheel was mounted to the robot and I mounted the electronics.  The robot is ready for field testing now.  \\r\\n![](flywheel_on_bot.jpg)\\r\\n\\r\\n## Testing and Iterating\\r\\nThe robot is inconsistent currently but everything seems to work.  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/e__h1EIPCsE?si=plh5BLYtWQ6PJsr5\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\nThe robot needs to be able to spin rollers too.  I added this piece of metal to check where I needed to add a wheel relative to the slider.  This lets me design something nicer to house the wheel.  \\r\\n![](roller_with_c.jpg)\\r\\n\\r\\nUsing various washers and wheels, I designed this piece of polycarbonate to hold the roller in the same place as the image above.  \\r\\n![](poly_layout.jpg)\\r\\n![](roller_mounted.jpg)\\r\\n\\r\\nA problem the slider has is friction while it\'s moving.  It changes speeds throughout the motion because the prints are wearing out due to contact with the polycarbonate.  \\r\\n![](slider_degrading.jpg)\\r\\n\\r\\nI redesigned the slider to have rollers contact the polycarbonate instead and this improved friction and the speed of the slider immensely. \\r\\n![](new_slider.jpg)\\r\\n\\r\\n## Software\\r\\n\\r\\n### Flywheel\\r\\nFor flywheel speed control I use a mix of bang-bang, velocity PID, and feed-forward.  \\r\\n\\r\\nI have a task running that has 4 states:\\r\\n- if the target rpm is 0, do nothing\\r\\n- if the current rpm is less than the target, go full power\\r\\n- if the current rpm is within some threshold of the target, use feed-forward and velocity PID to hold a speed\\r\\n- if the current rpm is faster than the target, slowdown the flywheel just using feed-forward\\r\\n\\r\\nFor feed forward, I made a simple graph to figure out what voltage is needed to get to a desired RPM.  I set the voltage of the flywheel to 127 and after letting it accelerate up to speed, I measured my flywheel\'s average rpm over that time.  I did the same test with setting 63 to the flywheel instead.  This gives me two data points that I can make a line off of and figure out an estimated voltage for any desired rpm.  \\r\\n```cpp\\r\\n// Tested data points\\r\\nconst double max[2] = {1617, 127};\\r\\nconst double min[2] = {813, 63};\\r\\n\\r\\n// Calculating m and b\\r\\nconst double m = (max[1] - min[1]) / (max[0] - min[0]);\\r\\nconst double b = max[1] - (m * max[0]);\\r\\n```\\r\\n\\r\\nCalculating the estimated voltage required (we\'re calling this \\"hold power\\") we can input the desired rpm into `y=mx+b`.  \\r\\n```cpp\\r\\n// Calculate theoretical power to hold rpm\\r\\ndouble hold_power = (targetRPM * m) + b;\\r\\n``` \\r\\n\\r\\nPID is generally used as a position controller.  This does not plug and play into a velocity controller.  What happens is as we get closer to the desired rpm, the voltage would drop.  I run PID for the flywheel but I `+=` it to the flywheel, so the closer we get to the desired rpm the less power we add to the flywheel.  I add the PID output to `hold_power`.  \\r\\n```cpp\\r\\nflywheelPID.set_target(targetRPM);\\r\\nflywheelPID.compute(getRPM());\\r\\noutput = hold_power + flywheelPID.output;\\r\\n```\\r\\n\\r\\nPutting this all together in a task looks like this.  \\r\\n```cpp\\r\\n// Control flywheels velocity\\r\\nvoid flywheel_control() {\\r\\n  // Tested data points\\r\\n  const double max[2] = {1617, 127};\\r\\n  const double min[2] = {813, 63};\\r\\n\\r\\n  // Calculating m and b\\r\\n  const double m = (max[1] - min[1]) / (max[0] - min[0]);\\r\\n  const double b = max[1] - (m * max[0]);\\r\\n\\r\\n  const double thresh = 100;\\r\\n  double output = 0;\\r\\n\\r\\n  PID flywheelPID(0, 0.0008, 0, thresh);\\r\\n  flywheelPID.reset_i_sgn = false;\\r\\n\\r\\n  bool last_competition_state = !pros::competition::is_disabled();\\r\\n  bool just_disabled = true;\\r\\n\\r\\n  while (true) {\\r\\n    // Calculate theoretical power to hold rpm\\r\\n    double hold_power = (targetRPM * m) + b;\\r\\n\\r\\n    // If the target is 0 do nothing\\r\\n    if (targetRPM == 0) {\\r\\n      output = 0;\\r\\n    }\\r\\n\\r\\n    // If the flywheel is slower than then target rpm, go max speed\\r\\n    else if (getRPM() <= targetRPM - thresh) {\\r\\n      output = 127;\\r\\n    }\\r\\n\\r\\n    // When flywheel is faster than then target rpm, go 0\\r\\n    else if (getRPM() >= targetRPM + thresh) {\\r\\n      output = hold_power;\\r\\n    }\\r\\n\\r\\n    // When the flywheel is within deadband, run I controller\\r\\n    else {\\r\\n      flywheelPID.set_target(targetRPM);\\r\\n      flywheelPID.compute(getRPM());\\r\\n      output = hold_power + flywheelPID.output;\\r\\n    }\\r\\n\\r\\n    output = clip_num(output, 127, 0);\\r\\n    set_flywheel(output);\\r\\n\\r\\n    if (pros::competition::is_disabled() && !last_competition_state) {\\r\\n      just_disabled = true;\\r\\n    } else if (!pros::competition::is_disabled()) {\\r\\n      flywheel_stopped = false;\\r\\n    }\\r\\n    last_competition_state = pros::competition::is_disabled();\\r\\n    if (just_disabled && getRPM() == 0) {\\r\\n      just_disabled = false;\\r\\n      flywheel_stopped = true;\\r\\n      tare_flywheel();\\r\\n    }\\r\\n\\r\\n    pros::delay(DELAY_TIME);\\r\\n  }\\r\\n}\\r\\npros::Task flywheelControl(flywheel_control);\\r\\n```\\r\\n\\r\\n### Indexer\\r\\nThe indexer uses a chunk of code I\'ve been iterating throughout the last couple of seasons.  I use this code for lifts to automatically zero the motor sensor when the lift comes down, and to apply a tiny bit of power to the lift to make sure it holds down.  This gives a huge quality of life improvement.  \\r\\n```cpp\\r\\n// Indexer task\\r\\nvoid indexer_control() {\\r\\n  slider_motor.set_brake_mode(MOTOR_BRAKE_BRAKE);\\r\\n  indexerPID.set_exit_condition(20, 5, 50, 10, 250, 250);\\r\\n  double output = 0;\\r\\n  long timer = 0;\\r\\n  bool did_reset = false;\\r\\n  const int reset_time = 30;\\r\\n  bool zerod = false;\\r\\n  while (true) {\\r\\n    // Current left and right sensors\\r\\n    double current = slider_motor.get_position();\\r\\n\\r\\n    // Computes PID and clips the speed to max speed\\r\\n    double clipped_pid = clip_num(indexerPID.compute(current), abs(indexer_speed), -abs(indexer_speed));\\r\\n\\r\\n    // Instead of using PID to come down, the robot will set the lift to some power, and when the velocity of the motor is 0\\r\\n    // (the motor is at the bottom), will reset the encoders so the PID will continue to work.\\r\\n    if (indexer_state == 0) {\\r\\n      if (current >= positions[1]) {\\r\\n        output = clipped_pid;\\r\\n      } else {\\r\\n        bool check = (slider_motor.get_actual_velocity() == 0 && !pros::competition::is_disabled()) ? true : false;\\r\\n        if (check) timer += DELAY_TIME;\\r\\n        if (timer >= reset_time) {\\r\\n          output = -5;\\r\\n          if (!did_reset) slider_motor.tare_position();\\r\\n          did_reset = true;\\r\\n          timer = reset_time;\\r\\n          zerod = true;\\r\\n        } else {\\r\\n          int speed = !zerod ? -127 : -90;\\r\\n          output = speed;\\r\\n        }\\r\\n      }\\r\\n    } else {\\r\\n      timer = 0;\\r\\n      did_reset = false;\\r\\n      output = clipped_pid;\\r\\n    }\\r\\n\\r\\n    if (pros::competition::is_disabled()) timer = 0;\\r\\n\\r\\n    // printf(\\"output: %f  pos: %f\\\\n\\", output, current);\\r\\n    set_indexer(output);\\r\\n\\r\\n    pros::delay(DELAY_TIME);\\r\\n  }\\r\\n}\\r\\npros::Task indexerControl(indexer_control);\\r\\n```\\r\\n\\r\\nFor the user control, I was able to press a button and have the slider push all 3 discs out, or I was able to iterate between each position and only shoot a single disc.  \\r\\n```cpp\\r\\n// Opcontrol indexer\\r\\nbool b_indexer_last = false;\\r\\nvoid indexer_opcontrol() {\\r\\n  if (getRPM() >= 500) {\\r\\n    if (master.get_digital_new_press(B_INDEXER) && !master.get_digital(B_SHIFT)) {\\r\\n      indexer_state = positions.size() - 1;\\r\\n      set_indexer_state(indexer_state);\\r\\n    }\\r\\n\\r\\n    if (master.get_digital(B_INDEXER) && master.get_digital(B_SHIFT) && !b_indexer_last) {\\r\\n      indexer_state++;\\r\\n      if (indexer_state >= positions.size()) indexer_state = 0;\\r\\n      set_indexer_state(indexer_state);\\r\\n    }\\r\\n    b_indexer_last = master.get_digital(B_INDEXER);\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n### Intake\\r\\nThe intake uses some code I\'ve been calling \\"anti-jam\\".  It uses the velocity of the motor to decide if the motor should be spinning or not, and if there\'s no motion out of the motor when there should be then we decide we\'re in a \\"jammed\\" state.  The intake will spin in the opposite direction for some amount of time to try to get whatever is in it out, then continue to intake.  \\r\\n\\r\\nWe check if the intake velocity is 0 when it shouldn\'t be for some amount of time, and then we start spinning the motor backward for some amount of time.  This is all wrapped in a way where using the intake feels like normal, I can use `set_intake()` and pass a parameter of -127 to 127 and everything gets handled in the background.  \\r\\n```cpp\\r\\n// Intake task with antijam logic\\r\\nvoid intake_task() {\\r\\n  const int wait_time = 30;\\r\\n  const int outtake_time = 70;\\r\\n  int jam_counter = 0;\\r\\n  bool is_jammed = false;\\r\\n\\r\\n  while (true) {\\r\\n    // Run intake full power in opposite direction for 250ms when jammed, then\\r\\n    // set intake back to normal\\r\\n    if (is_jammed) {\\r\\n      raw_set_intake(-127 * sgn(target_speed));\\r\\n      jam_counter += DELAY_TIME;\\r\\n      if (jam_counter > outtake_time) {\\r\\n        is_jammed = false;\\r\\n        jam_counter = 0;\\r\\n        raw_set_intake(target_speed);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // Detect a jam if velocity is 0 for 250ms\\r\\n    else if (target_speed != 0 && intake_motors[0].get_actual_velocity() == 0) {\\r\\n      jam_counter += DELAY_TIME;\\r\\n      if (jam_counter > wait_time) {\\r\\n        jam_counter = 0;\\r\\n        is_jammed = true;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (target_speed == 0) {\\r\\n      jam_counter = 0;\\r\\n    }\\r\\n\\r\\n    pros::delay(DELAY_TIME);\\r\\n  }\\r\\n}\\r\\npros::Task Intake_Task(intake_task);\\r\\n\\r\\nvoid intake_opcontrol() {\\r\\n  if (master.get_digital(B_INTAKE_IN))\\r\\n    set_intake(master.get_digital(B_SHIFT) ? 60 : 127);\\r\\n  else if (master.get_digital(B_INTAKE_OUT))\\r\\n    set_intake(master.get_digital(B_SHIFT) ? -60 : -127);\\r\\n  else if (!master.get_digital(B_INTAKE_IN) && !master.get_digital(B_INTAKE_OUT))\\r\\n    set_intake(0);\\r\\n}\\r\\n```\\r\\n\\r\\nFor the slider to engage with the discs the slider must be down.  This is handled in the intake function, setting the indexer state to `0` on the rising action of setting the intake.  \\r\\n```cpp\\r\\n// For use in this file only\\r\\nvoid raw_set_intake(int input) {\\r\\n  for (auto i : intake_motors) {\\r\\n    i.move_voltage(input * (12000.0 / 127.0));\\r\\n  }\\r\\n\\r\\n  // On rising action of intake being set, set indexer state to 0\\r\\n  if (input > 100 && last_input < 100)\\r\\n    set_indexer_state(0);\\r\\n  last_input = input;\\r\\n}\\r\\n\\r\\n// This is used outside of this file\\r\\nvoid set_intake(int input) {\\r\\n  raw_set_intake(input);\\r\\n  target_speed = input;\\r\\n}\\r\\n```\\r\\n\\r\\n## Conclusion\\r\\nThis robot ended up being extremely useful for:\\r\\n- showcasing the engineering design process\\r\\n- showcasing how to iterate off of someone else\'s work\\r\\n- how to verify someone else\'s tests\\r\\n- scrimmaging with my students\\r\\n- teaching me the nuances of building a robot to handle these game elements\\r\\n![](banner.jpg)"},{"id":"harvard-westlake-blz-i","metadata":{"permalink":"/projects/harvard-westlake-blz-i","source":"@site/projects/2022-07-22-harvard-westlake-blzi/index.md","title":"Harvard-Westlake- BLZ-i","description":"Inspired by the 118 Everybot, Harvard-Westlake wanted to make simple, competitive designs for the VEX Robotics Competition Spin-Up.","date":"2022-07-22T00:00:00.000Z","formattedDate":"July 22, 2022","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"mentoring","permalink":"/projects/tags/mentoring"},{"label":"tutorials","permalink":"/projects/tags/tutorials"},{"label":"spin up","permalink":"/projects/tags/spin-up"},{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"software","permalink":"/projects/tags/software"},{"label":"cad","permalink":"/projects/tags/cad"}],"readingTime":0.6933333333333334,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"harvard-westlake-blz-i","title":"Harvard-Westlake- BLZ-i","authors":["jess"],"tags":["vex","mentoring","tutorials","spin up","hardware","software","cad"]},"unlisted":false,"prevItem":{"title":"EZ Mid","permalink":"/projects/mid"},"nextItem":{"title":"VEXcode Tutorials","permalink":"/projects/vexcode-tutorials"}},"content":"Inspired by the [118 Everybot](https://www.118everybot.org/), Harvard-Westlake wanted to make simple, competitive designs for the VEX Robotics Competition Spin-Up.  \\r\\n\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/_EREBglZZcA?si=cn0sSXxFQpLpzNfr\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nHarvard-Westlake hosted three one-week long summer camps where ~12 students would come for a one-week intensive of robotics where we wanted to condense an entire season into one week.  We split students into 4 groups and had each group assemble BLZ-i.  The goal of the summer camp is to teach students the importance of build quality and how it leads to consistency and longevity in every part of a robot.  \\r\\n\\r\\nDuring this one-week intensive, students learned build quality, and the importance of squaring drives, and had a full day and a half of tournaments where over 20 matches were run.  Students learned to maintain their robots as screws would come loose and learned to iterate flaws in the design in an attempt to make it more consistent. \\r\\n\\r\\nMy role in the summer camp was to mentor students in build quality, maintaining and iterating the example robots to be more consistent and easier to assemble, and assisting anywhere I could in students taking the lead on software that becomes public for the [forum post](https://www.vexforum.com/t/harvard-westlake-robotics-blz-i-reveal/104867)."},{"id":"vexcode-tutorials","metadata":{"permalink":"/projects/vexcode-tutorials","source":"@site/projects/2022-02-14-vexcode-tutorials/index.md","title":"VEXcode Tutorials","description":"After I saw the success of the CAD tutorials, I decided to do the same for code.  I made click-by-click tutorials on code concepts to enable students to ask specific questions instead of \\"How do I code the robot?\\".","date":"2022-02-14T00:00:00.000Z","formattedDate":"February 14, 2022","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"mentoring","permalink":"/projects/tags/mentoring"},{"label":"tutorials","permalink":"/projects/tags/tutorials"},{"label":"software","permalink":"/projects/tags/software"},{"label":"open source","permalink":"/projects/tags/open-source"},{"label":"wip","permalink":"/projects/tags/wip"}],"readingTime":0.7933333333333333,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"vexcode-tutorials","title":"VEXcode Tutorials","authors":["jess"],"tags":["vex","mentoring","tutorials","software","open source","wip"]},"unlisted":false,"prevItem":{"title":"Harvard-Westlake- BLZ-i","permalink":"/projects/harvard-westlake-blz-i"},"nextItem":{"title":"Dave","permalink":"/projects/dave"}},"content":"After I saw the success of the CAD tutorials, I decided to do the same for code.  I made [click-by-click tutorials](https://github.com/EZ-Robotics/VEXcode-Tutorials) on code concepts to enable students to ask specific questions instead of \\"How do I code the robot?\\".   \\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nThere are tutorials for super kit robots, and there are discussions on forums about advanced software like pure pursuit and motion profiling, but there is a lack of resources for the middle ground.  Code that is more complex than moving the robot with joysticks, and less complex than motion profiling.  That\'s where these tutorials come in.\\r\\n\\r\\nThe tutorials start basic with spinning motors, joystick control, and more advanced control schemes like toggles, ladders, feedback loops using P from PID, and a GUI selector for selecting an autonomous routine. \\r\\n\\r\\nThe biggest difference between teaching CAD and code through documentation is people can copy/paste code, and cannot copy/paste CAD without the source files.  To combat this I made sure to have a section on debugging, which goes into how to use the `printf()` function to read what variables are set to.  \\r\\n\\r\\nIn autonomous routines for VRC, robots usually move straight and turn.  I wanted to teach students how to use feedback controllers to get the robot to move, but if I have code for turning and driving students will copy/paste both.  I only have a tutorial for turning, and students can extrapolate how to modify the code for going straight."},{"id":"dave","metadata":{"permalink":"/projects/dave","source":"@site/projects/2021-12-1-dave/index.md","title":"Dave","description":"Dave was a little robot that I made quickly for testing software.  Everything on it is either 3D printed or laser cut from Send Cut Send.","date":"2021-12-01T00:00:00.000Z","formattedDate":"December 1, 2021","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"software","permalink":"/projects/tags/software"},{"label":"cad","permalink":"/projects/tags/cad"}],"readingTime":0.86,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"dave","title":"Dave","authors":["jess"],"tags":["vex","hardware","software","cad"]},"unlisted":false,"prevItem":{"title":"VEXcode Tutorials","permalink":"/projects/vexcode-tutorials"},"nextItem":{"title":"Printable ESD Board Case","permalink":"/projects/esd-board-case"}},"content":"Dave was a little robot that I made quickly for testing software.  Everything on it is either 3D printed or laser cut from [Send Cut Send](https://sendcutsend.com/).  \\r\\n![](banner.jpg)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nI started out with a double roller omni-wheel assembly that had a gear baked into the print.\\r\\n<img\\r\\n  src={require(\\"./wheel1.JPG\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"43%\\", height: \\"auto\\" }}\\r\\n/><img\\r\\n  src={require(\\"./wheel3.JPG\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"45%\\", height: \\"auto\\" }}\\r\\n/>\\r\\n\\r\\nI looked through my parts and found out I didn\'t have enough rollers from the old VEX 3.25\\" wheels, but I did have enough from their 4\\" wheels.  I redesigned the wheel using the dimensions from those rollers.  Left is 3.25\\" roller, right is 4\\". \\r\\n<img\\r\\n  src={require(\\"./wheel2.png\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"100%\\", height: \\"auto\\" }}\\r\\n/>\\r\\n\\r\\nI wanted all of the gearing to be enclosed in the drive so I needed smaller idler gears.  The ratio is 2:1, I\'ll be using a 1200rpm motor to make the output wheel go 600rpm. \\r\\n![](innergears2.png)\\r\\n![](innergears1.png)\\r\\n\\r\\nThe motor fronts were integrated into the drive, and the gearing was done!  All that was left was to make an electronics holder, a simple sheet to hold everything, and make sure there were cutouts for tracking wheels.\\r\\n![](fullcad1.png)\\r\\n![](fullcad2.png)\\r\\n\\r\\nThe assembly was very smooth.  Inserts got pressed into the wheels and they spun on round standoffs.  Everything else spun on screws.  \\r\\n![](notdone.jpg)\\r\\n\\r\\nAnd when assembly was all done, it looked just like the CAD!  The robot helped me program for about 6 months, but I had other more realistic robots to use for software testing then.  T\\r\\n![](outdoor.jpg)"},{"id":"esd-board-case","metadata":{"permalink":"/projects/esd-board-case","source":"@site/projects/2021-10-25-esd-board-case/index.md","title":"Printable ESD Board Case","description":"The exclusion of a TVS diode in the VEX V5 Brain leads to ports frying when mechanisms on the robot are more prone to static.  I made a 3D printable case for custom PCBs to solve this problem.","date":"2021-10-25T00:00:00.000Z","formattedDate":"October 25, 2021","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"open source","permalink":"/projects/tags/open-source"}],"readingTime":0.5466666666666666,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"esd-board-case","title":"Printable ESD Board Case","authors":["jess"],"tags":["vex","hardware","open source"]},"unlisted":false,"prevItem":{"title":"Dave","permalink":"/projects/dave"},"nextItem":{"title":"Harvard-Westlake- AMOGO x DOGO","permalink":"/projects/harvard-westlake-amogo-dogo"}},"content":"[The exclusion of a TVS diode in the VEX V5 Brain](https://wiki.purduesigbots.com/vex-electronics/vex-electronics/vex-v5-brain/v5-electronics-observations) leads to ports frying when mechanisms on the robot are more prone to static.  I made a [3D printable case](https://wiki.purduesigbots.com/vex-electronics/v5-esd-protection-board) for custom PCBs to solve this problem.\\r\\n\\r\\n![](banner.jpg)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nBLRS made a custom PCB with wire couplers that add a TVS diode between them.  Having a short wire from the brain to the coupler, then from the coupler to your motor makes it so the ports cannot break due to static.  These parts are explicitly illegal for competition use but are legal to use in practice.  \\r\\n\\r\\nMy involvement was designing the 3D printable case.  There are 3 versions that hold different amounts of boards,  1, 4, and 8.  The challenge was designing parts that fit the boards snugly on multiple types of printers.  During testing I had teams try printing them on an Ender 3, Prusa Mk3, and a Prusa Mini to make sure tolerances were good no matter what printer was used."},{"id":"harvard-westlake-amogo-dogo","metadata":{"permalink":"/projects/harvard-westlake-amogo-dogo","source":"@site/projects/2021-08-21-harvard-westlake-amogo-dogo/index.md","title":"Harvard-Westlake- AMOGO x DOGO","description":"Inspired by the 118 Everybot, Harvard-Westlake wanted to make simple, competitive designs for the VEX Robotics Competition Tipping Point.","date":"2021-08-21T00:00:00.000Z","formattedDate":"August 21, 2021","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"mentoring","permalink":"/projects/tags/mentoring"},{"label":"tutorials","permalink":"/projects/tags/tutorials"},{"label":"tipping point","permalink":"/projects/tags/tipping-point"},{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"software","permalink":"/projects/tags/software"},{"label":"cad","permalink":"/projects/tags/cad"}],"readingTime":2.1866666666666665,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"harvard-westlake-amogo-dogo","title":"Harvard-Westlake- AMOGO x DOGO","authors":["jess"],"tags":["vex","mentoring","tutorials","tipping point","hardware","software","cad"]},"unlisted":false,"prevItem":{"title":"Printable ESD Board Case","permalink":"/projects/esd-board-case"},"nextItem":{"title":"VEX CADing Tutorials","permalink":"/projects/vex-cadding-tutorials"}},"content":"Inspired by the [118 Everybot](https://www.118everybot.org/), Harvard-Westlake wanted to make simple, competitive designs for the VEX Robotics Competition Tipping Point.  \\r\\n\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/mmhPOVIbJWI?si=anLpK8ux69RY1DQh\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n## About\\r\\nHarvard-Westlake hosted three one-week long summer camps where ~12 students would come for a one-week intensive of robotics where we wanted to condense an entire season into one week.  We split students into 4 groups and had two groups make AMOGO and two groups make DOGO.  The goal of the summer camp is to teach students the importance of build quality and how it leads to consistency and longevity in every part of a robot.  \\r\\n\\r\\nDuring this one-week intensive, students learned build quality, and the importance of squaring drives, and had a full day and a half of tournaments where over 20 matches were run.  Students learned to maintain their robots as screws would come loose and learned to iterate flaws in the design in an attempt to make it more consistent. \\r\\n\\r\\nMy role in the summer camp was to mentor students in build quality, maintain and iterate the example robots to be more consistent and easier to assemble, and develop software for the robots that gives simple-to-use controls for students who haven\'t driven a robot before. I also responded to community questions on the [forums](https://www.vexforum.com/t/harvard-westlake-robotics-amogo-x-dogo-reveal/92670) to make sure as much information as possible was clear about these robots. \\r\\n\\r\\n## Code\\r\\n\\r\\nThere were two versions of the code for each robot, one made in [VEXcode](https://www.vexrobotics.com/vexcode) and one made in [PROS](https://pros.cs.purdue.edu/).  \\r\\n\\r\\n### VEXcode\\r\\nThe VEXcode versions of the code are much simpler and more digestible.  This is what most teams use to program their robots, so I wanted this code to be easily understandable by someone who had seen very little/no code before.  Everything is in a single file and all code relating to subsystems are bunched together so students can pick apart the code piece by piece.  \\r\\n[AMOGO VEXcode - GitHub](https://github.com/Unionjackjz1/HW-AMOGO-VEXCODE/)  \\r\\n[DOGO VEXcode - GitHub](https://github.com/Unionjackjz1/HW-DOGO-VEXCODE/)  \\r\\n\\r\\n### PROS\\r\\nOn the other hand, the PROS versions of the code are more complex.  The code is split up into multiple files, where each subsystem has its own file.  The code for the drive base was based on the first version of [EZ-Template](https://www.roboticsisez.com/ez-template), which was my codebase that dealt with PID for getting the robot from point A to point B with very little setup.  \\r\\n[AMOGO PROS - GitHub](https://github.com/Unionjackjz1/HW-AMOGO-PROS/)   \\r\\n[DOGO PROS - GitHub](https://github.com/Unionjackjz1/HW-DOGO-PROS/)  \\r\\n\\r\\nThe PROS version of the code also came with a more complex autonomous routine that could complete the Autonomous Win Point by itself.  The Autonomous Win Point is a series of tasks that an alliance must complete during Autonomous to get an additional ranking point.  Doing this task by yourself can guarantee more opportunities for additional ranking points.  Because of the importance of solo AWP, we wanted to showcase that these simple robots could accomplish it.  \\r\\n[AMOGO Solo AWP Autonomous Video](https://youtu.be/p1lgbKy1ZBE)  \\r\\n[DOGO Solo AWP Autonomous Video](https://youtu.be/wpvR_m3cUFk)\\r\\n\\r\\n## CAD\\r\\nThe CAD for each robot was also released so students could look at how different parts of the robot were assembled and see parts deep in the robot clearly.  There were some unique build techniques done specifically on the drive, where screws were used instead of axles.  \\r\\n[AMOGO CAD - STEP](https://drive.google.com/file/d/1teWAX4Hb_rwtznO7sPc-pv1EVGZGrDgA/view?usp=sharing)  \\r\\n[DOGO CAD - STEP](https://drive.google.com/file/d/1Y3QqJmkoS1UeejjGi8d0tq-_WFdEoL06/view?usp=sharing)  \\r\\n\\r\\n## Scrimmages\\r\\nAt the end of the day, VEX robotics is a sport where matches are played competitively.  Everything else that was done for these robots was educational, but the end goal for all of this was to compete with a robot.  Scrimmages were published of both example robots competing head to head, while I was operating DOGO.\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/yB3He_QHhds?si=IOW3jZL6EZ7wj8Cw\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/7XZg8rz2fpE?si=HI677s-tDK2tyWO3\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/NCoMXwhrikM?si=jPz_Y9EtdrjJtDcx\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>"},{"id":"vex-cadding-tutorials","metadata":{"permalink":"/projects/vex-cadding-tutorials","source":"@site/projects/2021-07-26-vex-cadding-tutorials/index.md","title":"VEX CADing Tutorials","description":"In order to reach the demand of students wanting to learn CAD, I developed click-by-click tutorials on how to CAD using Autodesk Inventor.","date":"2021-07-26T00:00:00.000Z","formattedDate":"July 26, 2021","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"mentoring","permalink":"/projects/tags/mentoring"},{"label":"tutorials","permalink":"/projects/tags/tutorials"},{"label":"cad","permalink":"/projects/tags/cad"},{"label":"open source","permalink":"/projects/tags/open-source"}],"readingTime":0.79,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"vex-cadding-tutorials","title":"VEX CADing Tutorials","authors":["jess"],"tags":["vex","mentoring","tutorials","cad","open source"]},"unlisted":false,"prevItem":{"title":"Harvard-Westlake- AMOGO x DOGO","permalink":"/projects/harvard-westlake-amogo-dogo"},"nextItem":{"title":"Ooga Booga & Frank","permalink":"/projects/vex-change-up"}},"content":"In order to reach the demand of students wanting to learn CAD, I developed [click-by-click tutorials](https://wiki.purduesigbots.com/vex-cad/making-a-chassis) on how to CAD using Autodesk Inventor.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nDuring COVID I taught CAD with Autodesk Inventor Professional to students who wanted to solidify designs without access to parts.  This was the easiest one-on-one over Zoom or Discord until it was eating hours of my time.  I decided instead to make written tutorials and the [BLRS Wiki](https://wiki.purduesigbots.com/) team was kind enough to let me host them there.  After a few weeks, I made a click-by-click tutorial on how to CAD using the VEX kit of parts.  Students were now able to ask me specific questions about a topic instead of having me hold their hands through the entire process.  The website has seen tens of thousands of people and many of my students have benefited from it. \\r\\n\\r\\nMy goal with the tutorial was to enable students to use CAD during their design process.  I was less concerned about them using best CAD practices.  I\'d rather students use CAD with worse practices than get discouraged at \\"rules\\" and never use CAD.  \\r\\n\\r\\nWith that, there are two tutorials.  [One for beginners](https://wiki.purduesigbots.com/vex-cad/making-a-chassis/inventor-chassis) to learn how to use connect parts, grounding, dark mode (obviously) and mirroring, and an [advanced tutorial](https://wiki.purduesigbots.com/vex-cad/making-a-chassis/inventor-chassis-best-practices) that teaches best practices while making a slightly more complex drive base.  The advanced tutorial teaches about using origin planes, making more subassemblies, and replacing components."},{"id":"vex-change-up","metadata":{"permalink":"/projects/vex-change-up","source":"@site/projects/2021-06-21-change-up-recap/index.md","title":"Ooga Booga & Frank","description":"Ooga Booga and Frank were the VEXU robots that my team built for Change Up.","date":"2021-06-21T00:00:00.000Z","formattedDate":"June 21, 2021","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"software","permalink":"/projects/tags/software"},{"label":"cad","permalink":"/projects/tags/cad"},{"label":"change up","permalink":"/projects/tags/change-up"}],"readingTime":1.1,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"vex-change-up","title":"Ooga Booga & Frank","authors":["jess"],"tags":["vex","hardware","software","cad","change up"]},"unlisted":false,"prevItem":{"title":"VEX CADing Tutorials","permalink":"/projects/vex-cadding-tutorials"},"nextItem":{"title":"Goofy - Robot in 3 Days","permalink":"/projects/goofy-ri3d"}},"content":"[Ooga Booga and Frank](https://photos.app.goo.gl/YkLtHVYeikCV3UZdA) were the VEXU robots that my team built for Change Up.  \\r\\n\\r\\n![](banner.jpg)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n## Ooga Booga\\r\\nOoga and Booga were tether bots that were connected by a 13ft wire.  Together they fit in size constraints as 1 robot, and because they are connected they are considered 1 robot.  \\r\\n![](oogabooga.jpg)\\r\\n\\r\\n### Ooga\\r\\nThis was the main robot that had the brain.  Ooga had 10 motors.  6 drive, 2 intake, 2 conveyor.  The intake pneumatically closed for taking balls out of the goals.  \\r\\n![](oogafront2.jpg)\\r\\n\\r\\n### Booga\\r\\nThis was the puppet robot.  Booga had 7 motors.  4 drive, 2 intake, and 1 conveyor.  \\r\\n\\r\\nThe intake on Booga is different from Ooga or Frank, where Booga had larger wheels.  These wheels helped increase the intake range of the robot by flexing out the way.  The larger wheel meant if we hit a wall the intake would stop spinning, we solved this by putting the wheel on a 3D-printed slip clutch.  \\r\\n\\r\\nThe conveyor had only 1 motor but needed 2 functions: holding onto balls and scoring.  This was accomplished with ratchets.  Inside the conveyor wheels are pawls and the gears all have ratchets on them.  When the motor goes in one direction, only the bottom roller spins up.  When the motor goes in the opposite direction, all of the rollers spin up.  The bottom wheel goes the same way regardless of the input because of inverted ratchets on each side, similar to [this video](https://youtu.be/y44_xMFsPQQ?si=VBdRDJc-SNT6OzlC).\\r\\n![](booga_1.jpg)\\r\\n\\r\\n## Frank\\r\\nFrank was a smaller 15\\" robot.  Frank had 11 motors.  6 drive, 2 on the intake, and 3 on the conveyor.  \\r\\n\\r\\nThe intake on Frank was almost identical to Ooga.  Pneumatically actuated for removing balls from goals.  \\r\\n\\r\\nFor the conveyor, Frank used rubber band rollers instead of urethane wheels.  The concept of both is the same, but on Frank, we used a harder back material and squishy rollers.  \\r\\n\\r\\nThe center traction wheel on Frank was 3d printed, and we molded polyurethane around it. \\r\\n\\r\\n![](frankleft1.jpg)"},{"id":"goofy-ri3d","metadata":{"permalink":"/projects/goofy-ri3d","source":"@site/projects/2019-06-27-goofy - ri3d/index.md","title":"Goofy - Robot in 3 Days","description":"Goofy was a RI3D (robot in 3 days) that I participated in during the start of Tower Takeover.  We gave ourselves 72 hours to go from no design to a fully complete robot.   At the end of 72 hours we filmed a reveal, made the code public, and made a VEXforum post to further share the design, and I edited a documentary that explains our design process.  Combined the reveal and documentary have over 200k views.","date":"2019-06-27T00:00:00.000Z","formattedDate":"June 27, 2019","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"software","permalink":"/projects/tags/software"},{"label":"tower takeover","permalink":"/projects/tags/tower-takeover"}],"readingTime":0.30666666666666664,"hasTruncateMarker":false,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"goofy-ri3d","title":"Goofy - Robot in 3 Days","authors":["jess"],"tags":["vex","hardware","software","tower takeover"]},"unlisted":false,"prevItem":{"title":"Ooga Booga & Frank","permalink":"/projects/vex-change-up"},"nextItem":{"title":"Turning Point - Keke","permalink":"/projects/keke"}},"content":"Goofy was a RI3D (robot in 3 days) that I participated in during the start of Tower Takeover.  We gave ourselves 72 hours to go from no design to a fully complete robot.   At the end of 72 hours we filmed a [reveal](https://youtu.be/QJI29QI5COM?si=_CvPY3BqpIup5Bqw), made the [code public](https://github.com/Unionjackjz1/Goofy-RI3D), and made a [VEXforum post](https://www.vexforum.com/t/448x-21s-6671x-and-1437z-ri3d-reveal/62602) to further share the design, and I edited a [documentary](https://youtu.be/BC4ZlIcBB7I?si=Kft1lqWfc1Vl6-A9) that explains our design process.  Combined the reveal and documentary have over 200k views.\\r\\n\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/BC4ZlIcBB7I?si=6x4MY6_HmAneCHuN\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>"},{"id":"keke","metadata":{"permalink":"/projects/keke","source":"@site/projects/2019-04-30-keke/index.md","title":"Turning Point - Keke","description":"Keke was my team\'s final competitive robot for the VRC season Turning point, my senior year of high school.  This robot used a catapult to shoot two balls at once to shoot two flags at once, could pick up and score caps and place them on poles, and could scrape balls off of caps or the platform.","date":"2019-04-30T00:00:00.000Z","formattedDate":"April 30, 2019","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"turning point","permalink":"/projects/tags/turning-point"},{"label":"software","permalink":"/projects/tags/software"},{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"cad","permalink":"/projects/tags/cad"}],"readingTime":2.83,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"keke","title":"Turning Point - Keke","authors":["jess"],"tags":["vex","turning point","software","hardware","cad"]},"unlisted":false,"prevItem":{"title":"Goofy - Robot in 3 Days","permalink":"/projects/goofy-ri3d"},"nextItem":{"title":"Spoon Wars","permalink":"/projects/spoonwars"}},"content":"Keke was my team\'s final competitive robot for the VRC season Turning point, my senior year of high school.  This robot used a catapult to shoot two balls at once to shoot two flags at once, could pick up and score caps and place them on poles, and could scrape balls off of caps or the platform.\\r\\n\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/ist1h6ZTdDc?si=6TjNYwcKvkhvQO0I\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nThis robot was started in late October and was the robot we took to the World Championship, the culmination of all of the work we put in throughout High School.\\r\\n\\r\\nMy contributions as team captain went to every aspect of the robot.  I wrote autonomous routines using motion profiling, and adding automation while operating to make it easier on the driver.  I designed different stable and low-slop joints than Pancake, but most of all designed a robot that required very little maintenance after taking a beating.\\r\\n![](worlds.jpg)\\r\\n\\r\\n\\r\\n## Notebook\\r\\nIn VEX teams can create engineering notebooks and can win awards based on those notebooks and an interview process.  This is the notebook, our build/software log, that we made for this robot.  \\r\\n\\r\\nThis was never finished, so I\'ll add a summary of the remainder of the season below.\\r\\n\\r\\nhttps://docs.google.com/document/d/1omhGB65uhTlaZRZvgxiF9jmN33fIssLbpcdErRU2LSE/edit?usp=sharing\\r\\n\\r\\nWe took the robot to SLO and were very happy with the performance, ranking 3rd and advancing to the finals.  Our biggest shortcoming was our autonomous not doing enough.  To be fair to our SLO performance, we were working on such a short schedule with how recently we got V5 and were able to put everything on the robot.  But there was something new we wanted to try. \\r\\n\\r\\nTeams have started making mechanisms to intake the balls off of caps during autonomous and using them to increase the efficiency of their paths.  We have an extra motor but would like to use it elsewhere, so we came up with a passive idea.  When our cap arm was raised it would release a rubber band allowing this standoff to fall into a cap, and when we drove backward the ball would tip into our robot.  This worked ok but was inconsistent and hindered intaking. So we decided to try something else.\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/sLf9FCNjxXg?si=PpYmkTMX0hM2RHRr\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\nWe decided to go a more typical route and make a motored arm, we called this a scraper.  This allowed us to tip caps, flip caps, and take balls off of caps and the platform.  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/q3p2t34UsUw?si=WRuaxvga89343oH4\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\nSoon we had to compete at Google, a signature event, where the winners would qualify for the World Championship.  We continued to practice and iterate on mechanisms that would fail to make them more robust.  We got picked in 8th place, and we made it to the semi-finals where we lost to the champions.  But, our Quarter Finals match is a good one.  We were against 1st place and our alliance was having trouble and was working on the robot.  The event couldn\'t wait any longer so we had to play as 1 team against 2.  And against all odds (with some luck) we ended up winning the match!\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/W3HrmSFPUpA?si=sLM_iQXf683_HbLx\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\nWe ended up taking this robot to the State Championship and got picked for eliminations by 2nd place, and we advanced to Finals which qualified us for the World Championship.\\r\\n\\r\\nBetween the State Championship and World Championship we wanted to iterate everything.  Our drive struggled to get onto the platform, and our intake wasn\'t very fast, our scraper would get caught in the net sometimes. \\r\\n\\r\\nWe started fixing our list of problems by changing the shape of our drive.  We exposed the front wheel so as we climbed the platform it was easier to get on.  We also redid our intake structure to make sure it was much stronger.\\r\\n![](start_of_rebuild.jpg)\\r\\n\\r\\nTo stop our scraper from getting entangled in the net we angled it back farther.  This required changing how the structure was done and needed chains instead of gears to fit everything.  \\r\\n![](scraper.jpg)\\r\\n\\r\\nA big criticism of double catapults is the inability to shoot 1 ball at a time.  We had space for a ball to sit in our intake, so we added a sensor to detect a ball there and stop the intake.  This allowed us flexibility in scoring, and to not waste 2 balls when we only needed to score 1 flag.\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/V6CQSywE5aw?si=X8tKsGa6JgXnVQVj\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/iCO3P55ZqEU?si=ol17lvWTlesXVRUx\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\nAnd then it was off to the world championships!  We went 7-3, got picked by the 3rd seed, and advanced to the finals of our division.  And we got some pretty good highlights...\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/AX5zH4IKJ5M?si=oKlNfiKg78-kU9UU\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>"},{"id":"spoonwars","metadata":{"permalink":"/projects/spoonwars","source":"@site/projects/2019-02-17-spoonwars/index.md","title":"Spoon Wars","description":"Spoon Wars was a pre-COVID tradition at CHAMPS Charter High School, where every senior was given a spoon and had to tag out another senior who wasn\'t holding their spoon.  In my senior year, some students in robotics were hosting it so I decided to use Google Sheets to make scores more clear.  Without this, scores are texted to a game master and they have to share what the scores are when they can.  Now anyone can click this link and see scores.","date":"2019-02-17T00:00:00.000Z","formattedDate":"February 17, 2019","tags":[{"label":"software","permalink":"/projects/tags/software"},{"label":"google sheets","permalink":"/projects/tags/google-sheets"}],"readingTime":0.8166666666666667,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"spoonwars","title":"Spoon Wars","authors":["jess"],"tags":["software","google sheets"]},"unlisted":false,"prevItem":{"title":"Turning Point - Keke","permalink":"/projects/keke"},"nextItem":{"title":"Turning Point - Pancake","permalink":"/projects/pancake"}},"content":"Spoon Wars was a pre-COVID tradition at CHAMPS Charter High School, where every senior was given a spoon and had to tag out another senior who wasn\'t holding their spoon.  In my senior year, some students in robotics were hosting it so I decided to use [Google Sheets](https://docs.google.com/spreadsheets/d/1-Mcza29aSLZmGfXjjmtLiWaP_RBs_sX8DOSbPZp0WEk/edit?usp=sharing) to make scores more clear.  Without this, scores are texted to a game master and they have to share what the scores are when they can.  Now anyone can click this link and see scores.\\r\\n\\r\\n![](banner.jpg)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nEach week was a phase that had a spin on the game.  In the first week we had Academy Wars, where everyone in the same academy was safe from each other and they had to tag other academy members out, and the second week we gave the top 3 winners a second spoon as a second life.  Interest in the game fizzled out after the second week and the game stopped.\\r\\n\\r\\nThis was my first time using Google Sheets.  I decided to make each week a phase, and we put a spin on the game every week.  Having a dedicated sheet for each week made it easy to have other trusted people input scores.  \\r\\n\\r\\nThe sheet automatically condenses white space from lists, removes people from lists once they are out, and automatically creates the top 10 on the front page.  The skills I learned from making this enabled me to be proficient at Google Sheets for projects in the future."},{"id":"pancake","metadata":{"permalink":"/projects/pancake","source":"@site/projects/2018-11-17-pancake/index.md","title":"Turning Point - Pancake","description":"Pancake was my team\'s first competitive robot of the VRC season Turning Point, my senior year of high school.  This robot used a flywheel to shoot hard plastic balls at flags and could pick up and rotate caps to score them on poles.","date":"2018-11-17T00:00:00.000Z","formattedDate":"November 17, 2018","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"turning point","permalink":"/projects/tags/turning-point"},{"label":"software","permalink":"/projects/tags/software"},{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"cad","permalink":"/projects/tags/cad"}],"readingTime":0.7266666666666667,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"pancake","title":"Turning Point - Pancake","authors":["jess"],"tags":["vex","turning point","software","hardware","cad"]},"unlisted":false,"prevItem":{"title":"Spoon Wars","permalink":"/projects/spoonwars"},"nextItem":{"title":"In the Zone - Gort","permalink":"/projects/gort"}},"content":"Pancake was my team\'s first competitive robot of the VRC season Turning Point, my senior year of high school.  This robot used a flywheel to shoot hard plastic balls at flags and could pick up and rotate caps to score them on poles.  \\r\\n\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/xFh4QxeF-aQ?si=EsCoHq24hh0QABfW\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n## Overview\\r\\n\\r\\nThis robot was started over the summer and was decommissioned in December.  This robot lasted for 164 days.  After all of our mistakes during the previous season, we decided to keep a robot together as long as possible, practice as much as we could, and tune as much as possible.  \\r\\n\\r\\nMy contributions as team captain went to every aspect of the robot.  I wrote software for driving autonomously using PID, regulating flywheel velocity with a custom velocity controller, and adding automation while operating to make it easier on the driver.  I designed stable and low-slop lift joints, a ball indexer that uses no motors, and a flip-out aligner to score caps.\\r\\n\\r\\nIn VEX teams can create engineering notebooks and can win awards based on those notebooks and an interview process.  This is the notebook, our build/software log, that we made for this robot.   \\r\\nhttps://docs.google.com/document/d/1YsQF98x46rvx_f4sj1xKEUWLEZXy9S-LXohFsXjMl4s/edit?usp=sharing\\r\\n![](banner.jpg)\\r\\n\\r\\nI made a CAD of the robot during the pandemic.\\r\\n![](pancake_cad.png)"},{"id":"gort","metadata":{"permalink":"/projects/gort","source":"@site/projects/2018-02-24-gort/index.md","title":"In the Zone - Gort","description":"Gort was my team\'s final competitive robot for the VRC season In the Zone. This robot is different from Geoffrey in that this robot would keep the mobile goal inside of the robot and stack cones internally.","date":"2018-02-24T00:00:00.000Z","formattedDate":"February 24, 2018","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"software","permalink":"/projects/tags/software"},{"label":"in the zone","permalink":"/projects/tags/in-the-zone"}],"readingTime":0.48,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"gort","title":"In the Zone - Gort","authors":["jess"],"tags":["vex","hardware","software","in the zone"]},"unlisted":false,"prevItem":{"title":"Turning Point - Pancake","permalink":"/projects/pancake"},"nextItem":{"title":"Middle of In the Zone","permalink":"/projects/middle-in-the-zone"}},"content":"Gort was my team\'s final competitive robot for the VRC season In the Zone. This robot is different from Geoffrey in that this robot would keep the mobile goal inside of the robot and stack cones internally.\\r\\n\\r\\n![](banner.jpg)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nThis robot had the potential to be amazing, and when it performed at its highest it was very good.  After the mistakes of how we spent the [middle of our season](https://www.roboticsisez.com/projects/middle-in-the-zone) and giving ourselves 1 month to build this robot, we did not have enough time to get this robot to the consistency it needed.    \\r\\n\\r\\n[GitHub Code](https://github.com/Unionjackjz1/GORT)\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/glahhBM9XQA?si=v3Sn6-h3PDXDrbJf\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/ommpbahUyoY?si=jPxcI-MGm3ebHPJ-\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/CQ5raQ1NLmo?si=vlvMu8niAEAHR2ux\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>"},{"id":"middle-in-the-zone","metadata":{"permalink":"/projects/middle-in-the-zone","source":"@site/projects/2018-1-18-middle-in-the-zone/index.md","title":"Middle of In the Zone","description":"At this point, we were qualified for the State Championship. We now had 3 months of no stress to build up a robot for States, and somehow my team and I built 8 robots in this time frame and only 1 worked which was Gort.  This is a recap of the 7 robots that didn\'t end up working and why we decided to scrap it.","date":"2018-01-18T00:00:00.000Z","formattedDate":"January 18, 2018","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"software","permalink":"/projects/tags/software"},{"label":"in the zone","permalink":"/projects/tags/in-the-zone"}],"readingTime":2.49,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"middle-in-the-zone","title":"Middle of In the Zone","authors":["jess"],"tags":["vex","hardware","software","in the zone"]},"unlisted":false,"prevItem":{"title":"In the Zone - Gort","permalink":"/projects/gort"},"nextItem":{"title":"In the Zone - Geoffrey","permalink":"/projects/geoffrey"}},"content":"At this point, we were qualified for the State Championship. We now had 3 months of no stress to build up a robot for States, and somehow my team and I built 8 robots in this time frame and only 1 worked which was Gort.  This is a recap of the 7 robots that didn\'t end up working and why we decided to scrap it.  \\r\\n\\r\\nI believe showcasing failure is just as important as showcasing successes.  Between Geoffrey and Gort there was a significant amount of failure, but the amount I learned from this process was invaluable.  Without learning how much of a mistake it was building so many robots and not spending any time tuning I wouldn\'t have succeeded in any future projects here.\\r\\n\\r\\nThe rest of this blog post is the definition of \\"try it and see\\". \\r\\n![](banner.gif)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n---\\r\\n## Robot #1: The Schlucas \\r\\n*this robot existed for 13 days*\\r\\n\\r\\nInspired by the [62A reveal](https://www.vexforum.com/t/62-early-season-reveal/43366), and feeling confident after qualifying for the State Championship, we decided to try and build a similar version of this robot.  We really liked how light and simple this robot was compared to how other robots looked.  \\r\\n\\r\\nThe problems with this robot were software and hardware.  At the time I didn\'t know how inverse kinematics works (or that it\'s not that complicated and I knew everything I needed to) so I was going to tune the movements for every cone.  The amount of force the zip tie intake took to grab a zone was very inconsistent, and getting the intake to spin correctly was hard.  \\r\\n\\r\\nHere\'s a good [album](https://photos.app.goo.gl/FW2f4SJD36dUvdjHA) of the robot failing to move how I want it to.\\r\\n\\r\\n![](1.banner.JPG)\\r\\n\\r\\n## Robot #2: Thinner is Better\\r\\n*this robot existed for 5 days*\\r\\n\\r\\nThe idea for this robot was to make everything super thin.  I don\'t have much more to go off of with the 3 photos I have of it.  \\r\\n\\r\\n![](2.banner.JPG)\\r\\n\\r\\n## Robot #3: Maybe a Little Wider\\r\\n*this robot existed for 6 days*\\r\\n\\r\\nThe base 4 bar was too thin and didn\'t leave enough room for the top 4 bar.  The construction of this robot is pretty similar starting out.\\r\\n![](3.banner.JPG)\\r\\n\\r\\nAfter realizing there wasn\'t enough clearance or stability to be consistent, I tried to salvage it by picking up cones from the side instead of in front of the robot.  How it was built led to some huge levers and bending, so this was scrapped.\\r\\n<img\\r\\n  src={require(\\"./3.mistake1.JPG\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"42%\\", height: \\"auto\\" }}\\r\\n/><img\\r\\n  src={require(\\"./3.salvage.JPG\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"57%\\", height: \\"auto\\" }}\\r\\n/>\\r\\n\\r\\n## Robot #4: The Widest Yet\\r\\n*this robot existed for 15 days (new record!)*\\r\\n\\r\\nSomehow on this robot, the opposite mistake was made.  This robot was too wide.\\r\\n\\r\\nAnd this robot was scrapped once we realized it was [too wide](https://photos.app.goo.gl/DroWQUHgZUwW2bti8).\\r\\n![](4.banner.JPG)\\r\\n\\r\\n## Robot #5: \\"Tube\\"\\r\\n*this robot existed for 10 days*\\r\\n\\r\\nWith a tournament in 10 days and a robot that we felt wasn\'t salvageable, we needed to come up with something simple to compete with and fast.  After some discussion with team members and other competitors, we decided to attempt a new design we were calling \\"Tube Bot\\".  This robot would do small stacks, but the idea was if we could do them fast enough then we could spend the majority of the match playing defense. \\r\\n<img\\r\\n  src={require(\\"./5.sketch.JPG\\").default}\\r\\n  alt=\\"Example banner\\"\\r\\n  style={{ width: \\"60%\\", height: \\"auto\\" }}\\r\\n/>\\r\\n\\r\\nThis robot will grab cones and drop them ~2ft onto the mobile goal.  If you\'re asking yourself \\"How would this be consistent?\\", I\'m asking myself the same question as I write this retroactively.  \\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/r4a08b07Xvw?si=zy-66ASxoDyFq9n8\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>\\r\\n\\r\\n\\r\\n## Robot #6: \\"Tube\\" v2\\r\\n*this \\"robot\\" existed for 4 days*  \\r\\n\\r\\nAfter the *great* success the robot had at the tournament, we decided to make another version.  Luckily, this is as far as we got.\\r\\n![](6.banner.JPG)\\r\\n\\r\\n## Robot #7: Finally a Normal Robot.  but smaller...\\r\\n*this robot existed for 15 days*  \\r\\n\\r\\nThis robot was a step in the right direction.  This had all of the traits of a \\"meta-design\\" that the entire community was iterating on and pushing forward, except everything was smaller on ours.  The clearance between the top and bottom four bars was almost 0 and they would scrape constantly, the few intakes we tried didn\'t fit because of how far the mobile goal was sticking out of the robot, and we had strange pneumatic leaks that we couldn\'t find. \\r\\n\\r\\n ![](7.banner.JPG)"},{"id":"geoffrey","metadata":{"permalink":"/projects/geoffrey","source":"@site/projects/2017-10-28-geoffrey/index.md","title":"In the Zone - Geoffrey","description":"Geoffrey was one of my team\'s first competitive robots for the VRC season In the Zone, my junior year of high school.  This robot was designed to pick up cones and place them on mobile goals, then lift the weighted mobile goal to place it inside a higher-scoring zone.","date":"2017-10-28T00:00:00.000Z","formattedDate":"October 28, 2017","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"software","permalink":"/projects/tags/software"},{"label":"in the zone","permalink":"/projects/tags/in-the-zone"}],"readingTime":0.4533333333333333,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"geoffrey","title":"In the Zone - Geoffrey","authors":["jess"],"tags":["vex","hardware","software","in the zone"]},"unlisted":false,"prevItem":{"title":"Middle of In the Zone","permalink":"/projects/middle-in-the-zone"},"nextItem":{"title":"Rerun","permalink":"/projects/rerun"}},"content":"Geoffrey was one of my team\'s first competitive robots for the VRC season In the Zone, my junior year of high school.  This robot was designed to pick up cones and place them on mobile goals, then lift the weighted mobile goal to place it inside a higher-scoring zone. \\r\\n![](banner.JPG)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nThis robot was the start of my build quality becoming more consistent and cleaner. \\r\\n\\r\\nThe strategy and design for this robot didn\'t make much sense.  We were going for an external stacker that was fast enough to beat out internal stackers, and watching back matches it\'s very clear this isn\'t true.  Match review isn\'t something that happened this season at all, and it shows with this robot.  \\r\\n\\r\\n[GitHub Code](https://github.com/Unionjackjz1/Geoffrey)\\r\\n<iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/h5NVu9EfAdU?si=z-xWTsUbHK21pApG\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" allowfullscreen></iframe>"},{"id":"rerun","metadata":{"permalink":"/projects/rerun","source":"@site/projects/2017-03-12-rerun/index.md","title":"Rerun","description":"Rerun allows you to record robot movements and play them back during autonomous.","date":"2017-03-12T00:00:00.000Z","formattedDate":"March 12, 2017","tags":[{"label":"vex","permalink":"/projects/tags/vex"},{"label":"software","permalink":"/projects/tags/software"},{"label":"open source","permalink":"/projects/tags/open-source"},{"label":"starstruck","permalink":"/projects/tags/starstruck"}],"readingTime":1.46,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"rerun","title":"Rerun","authors":["jess"],"tags":["vex","software","open source","starstruck"]},"unlisted":false,"prevItem":{"title":"In the Zone - Geoffrey","permalink":"/projects/geoffrey"},"nextItem":{"title":"Minecraft Plugin - Core","permalink":"/projects/minecraft-plugin-core"}},"content":"[Rerun](https://github.com/Unionjackjz1/ROBO-DANNY/blob/master/RerunFunctions.c  ) allows you to record robot movements and play them back during autonomous.\\r\\n\\r\\n![](banner.gif)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nRerun works by tracking the velocities of all motors on the robot and running a velocity controller during autonomous to match those velocities.  The biggest problem with this code is it cannot react to changes in the robot, such as different banding or friction on a mechanism.  This version of the code is best used soon after the recording is made to ensure little to no changes to the robot.  \\r\\n\\r\\nWhile recording, the code would print to the terminal in a format that could be copied/pasted back into the code for running autonomously. \\r\\n```cpp\\r\\ntask\\r\\nrecord( ) {\\r\\n    startTask( calculateRPMs );\\r\\n    int j = 20, s = 1;\\r\\n    for( int i = 0; i < 400; i++ ) {\\r\\n        if( j == 20 ) {\\r\\n            writeDebugStream( \\"\\\\n\\" );\\r\\n            writeDebugStream( \\"\\\\n   /* %i Second(s) */\\", s );\\r\\n            s++;\\r\\n            j = 0;\\r\\n        }\\r\\n        j++;\\r\\n\\r\\n        writeDebugStream( \\"\\\\n   auton( %i, %i, %i, %i, %i, %i, %i, %i);\\", iArmCurrentRPM, motor[ arm_l1 ], iChassisLeftRPM, motor[ chassis_l ], iChassisRightRPM, motor[ chassis_r ], iClawRPM, motor[ intake_l ] );\\r\\n\\r\\n        delay( 50 );\\r\\n    }\\r\\n    stopTask( calculateRPMs );\\r\\n    writeDebugStream( \\"\\\\n\\\\n /* Stop the robot */\\\\n  auton( 0, 0, 0, 0, 0, 0, %i, %i );\\", iClawRPM, motor[ intake_l ] );\\r\\n}\\r\\n```\\r\\n\\r\\nPlaying the recorded run back uses a velocity controller.  The velocity controller is a P loop that `+=` to the motor.  This means if the motor is behind a bit, the motor will get a kick to get up to speed.  This is more accurate than setting the same PWM signal to the motors because it ensures at least the velocities are the same.  \\r\\n\\r\\nThe drivetrain used a modified version of this system.  I kept track of the PWM signal being sent to the drive as well, so the velocity controller used the recorded PWM signal as a starting point and modified it from there. \\r\\n\\r\\n```cpp\\r\\nvoid\\r\\nauton( int iArmDes, int iArmSpeed, int iChassisLeftDes, int iChassisLeftSpeed, int iChassisRightDes, int iChassisRightSpeed, int iClawDes, int iClawSpeed ) {\\r\\n    int iArmError = 0, iChassisLeftError = 0, iChassisRightError = 0, iClawError = 0;\\r\\n    for( int i = 0; i < 50; i++ ) {\\r\\n        iArmError          -= (iArmDes - iArmCurrentRPM) * 0.015;\\r\\n        iChassisLeftError  -= (iChassisLeftDes - iChassisLeftRPM) * 0.01;\\r\\n        iChassisRightError -= (iChassisRightDes - iChassisRightRPM) * 0.01;\\r\\n        iClawError         -= (iClawDes - iClawRPM) * 0.01;\\r\\n\\r\\n        arm( iArmError + iArmSpeed );\\r\\n        motor[ intake_l ] =\\r\\n        motor[ intake_r ] = (iClawError + iClawSpeed );\\r\\n\\r\\n        if( !bSide )\\r\\n            tankWithoutTrueSpeed( iChassisLeftError + iChassisLeftSpeed, iChassisRightError + iChassisRightSpeed );\\r\\n        else\\r\\n            tankWithoutTrueSpeed( iChassisRightError + iChassisRightSpeed, iChassisLeftError + iChassisLeftSpeed );\\r\\n\\r\\n        delay( 1 );\\r\\n    }\\r\\n}\\r\\n```"},{"id":"minecraft-plugin-core","metadata":{"permalink":"/projects/minecraft-plugin-core","source":"@site/projects/2016-01-25-minecraft-plugin/index.md","title":"Minecraft Plugin - Core","description":"Core is a simple Minecraft Bukkit plugin with the goal of being a lightweight replacement for all the features of Essentials that I used in my servers.","date":"2016-01-25T00:00:00.000Z","formattedDate":"January 25, 2016","tags":[{"label":"software","permalink":"/projects/tags/software"},{"label":"open source","permalink":"/projects/tags/open-source"},{"label":"minecraft","permalink":"/projects/tags/minecraft"}],"readingTime":0.17666666666666667,"hasTruncateMarker":false,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"minecraft-plugin-core","title":"Minecraft Plugin - Core","authors":["jess"],"tags":["software","open source","minecraft"]},"unlisted":false,"prevItem":{"title":"Rerun","permalink":"/projects/rerun"},"nextItem":{"title":"Destiny Nerf Blaster","permalink":"/projects/nerf-destiny"}},"content":"Core is a simple [Minecraft](https://www.minecraft.net/en-us) [Bukkit](https://dev.bukkit.org/) plugin with the goal of being a lightweight replacement for all the features of [Essentials](https://essentialsx.net/) that I used in my servers. \\r\\n\\r\\nImplemented features of [Core](https://github.com/Unionjackjz1/Core) included teleporting between players, feeding to full hunger, healing to full health, announcements on server join and leave, and changing game mode."},{"id":"nerf-destiny","metadata":{"permalink":"/projects/nerf-destiny","source":"@site/projects/2015-02-24-nerf-destiny/index.md","title":"Destiny Nerf Blaster","description":"After watching a friend play Destiny I wanted to make something inspired by that game\'s aesthetic.","date":"2015-02-24T00:00:00.000Z","formattedDate":"February 24, 2015","tags":[{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"nerf","permalink":"/projects/tags/nerf"}],"readingTime":0.4166666666666667,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"nerf-destiny","title":"Destiny Nerf Blaster","authors":["jess"],"tags":["hardware","nerf"]},"unlisted":false,"prevItem":{"title":"Minecraft Plugin - Core","permalink":"/projects/minecraft-plugin-core"},"nextItem":{"title":"Mavshot Nerf Blaster","permalink":"/projects/nerf-mavshot"}},"content":"After watching a friend play Destiny I wanted to make something inspired by that game\'s aesthetic.  \\r\\n\\r\\nThis was a [Nerf Longshot](https://nerf.fandom.com/wiki/Longshot_CS-12) that I did minimal modifications to on the exterior functionally.  I used a Dremel to cut a portion of the front off to look more streamlined.  \\r\\n\\r\\n![](banner.png)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nFor the inside of the blaster, I removed the air restrictors and added a stronger spring.  I also improved the seal on the plunger by making the o-ring a little wider and adding white lithium grease for lubrication.  This combination of modifications made foam darts go well over 100ft.\\r\\n\\r\\nFor the exterior, I painted this all white and used dark blue enamel for detailing.  Some black dry brushing later, this is looked like a used blaster."},{"id":"nerf-mavshot","metadata":{"permalink":"/projects/nerf-mavshot","source":"@site/projects/2013-02-20-nerf-mavshot/index.md","title":"Mavshot Nerf Blaster","description":"Mavshot was one of my first successful projects that I built when I was 11.  This is a Nerf Longshot body with a Nerf Maverick attached underneath.","date":"2013-02-20T00:00:00.000Z","formattedDate":"February 20, 2013","tags":[{"label":"hardware","permalink":"/projects/tags/hardware"},{"label":"nerf","permalink":"/projects/tags/nerf"}],"readingTime":0.5966666666666667,"hasTruncateMarker":true,"authors":[{"name":"Jess Zarchi","title":"Roboticist","url":"https://roboticsisez.com","imageURL":"https://github.com/Unionjackjz1.png","key":"jess"}],"frontMatter":{"slug":"nerf-mavshot","title":"Mavshot Nerf Blaster","authors":["jess"],"tags":["hardware","nerf"]},"unlisted":false,"prevItem":{"title":"Destiny Nerf Blaster","permalink":"/projects/nerf-destiny"}},"content":"Mavshot was one of my first successful projects that I built when I was 11.  This is a [Nerf Longshot](https://nerf.fandom.com/wiki/Longshot_CS-12) body with a [Nerf Maverick](https://nerf.fandom.com/wiki/Maverick_REV-6#Standard_) attached underneath.  \\r\\n\\r\\n![](banner.png)\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nI cut parts of the Longshot off with a Dremel and the handle off of the Maverick to join the two.  They are put together with hot glue, where a PVC pipe painted silver covers the seam.  \\r\\n\\r\\nI removed the air restrictors from the chambers of both blasters with a flathead screwdriver and a hammer.  The spring in the maverick was made stronger with a Home Depot spring.  I had to shave a portion of the pullback on the Maverick so a magazine would fit inside the longshot.\\r\\n\\r\\nOnce functional modifications were done, I sanded the parts heavily to remove the factory paint and put a base coat of black on.  I brushed on red and silver enamel paint for detailing.  \\r\\n\\r\\nThe guiding force of YouTube and multiple blasters I made nonfunctional were the driving forces for me to finally get a blaster that had everything 6th grade me wanted."}]}')}}]);