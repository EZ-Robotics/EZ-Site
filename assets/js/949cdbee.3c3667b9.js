"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7533],{2755:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>h});var n=r(5893),a=r(1151);const o={slug:"pure-pursuit",title:"Pure Pursuit",authors:["jess"],tags:["vex","software","wip"]},i=void 0,s={permalink:"/EZ-Site/projects/pure-pursuit",source:"@site/projects/2023-03-21-pure-pursuit/index.md",title:"Pure Pursuit",description:'Pure Pursuit is a path-tracking algorithm that enables a robot to chase a "carrot on a stick".',date:"2023-03-21T00:00:00.000Z",formattedDate:"March 21, 2023",tags:[{label:"vex",permalink:"/EZ-Site/projects/tags/vex"},{label:"software",permalink:"/EZ-Site/projects/tags/software"},{label:"wip",permalink:"/EZ-Site/projects/tags/wip"}],readingTime:5.09,hasTruncateMarker:!0,authors:[{name:"Jess Zarchi",title:"Roboticist",url:"https://roboticsisez.com",imageURL:"https://github.com/Unionjackjz1.png",key:"jess"}],frontMatter:{slug:"pure-pursuit",title:"Pure Pursuit",authors:["jess"],tags:["vex","software","wip"]},unlisted:!1,prevItem:{title:"EZ-Template",permalink:"/EZ-Site/projects/about-ez-template"},nextItem:{title:"The Pushbot",permalink:"/EZ-Site/projects/the-pushbot"}},l={authorsImageUrls:[void 0]},h=[{value:"Position Tracking",id:"position-tracking",level:2},{value:"Mecanum Drive",id:"mecanum-drive",level:2},{value:"Point to Point",id:"point-to-point",level:3},{value:"Paths with Strafe",id:"paths-with-strafe",level:3},{value:"Final Mecanum",id:"final-mecanum",level:3},{value:"Tank Drive",id:"tank-drive",level:2}];function c(e){const t={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",hr:"hr",img:"img",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://www.mathworks.com/help/nav/ug/pure-pursuit-controller.html",children:"Pure Pursuit"}),' is a path-tracking algorithm that enables a robot to chase a "carrot on a stick".']}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:r(6655).Z+"",width:"579",height:"189"})}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.p,{children:"Pure Pursuit is a tracking algorithm that allows a robot to follow a given path by following a point some distance ahead like a carrot on a stick.  It requires some way of knowing where your current position is and a generated path."}),"\n",(0,n.jsx)(t.h2,{id:"position-tracking",children:"Position Tracking"}),"\n",(0,n.jsx)(t.p,{children:"Position tracking is a piece of code that given 2 or 3 encoders you can extrapolate the X, Y, and angle of the robot."}),"\n",(0,n.jsxs)(t.p,{children:["This is explained far better by others, and here are the resources that I used:",(0,n.jsx)(t.br,{}),"\n",(0,n.jsx)(t.a,{href:"https://wiki.purduesigbots.com/software/odometry",children:"5225A Tracking Documentation"}),(0,n.jsx)(t.br,{}),"\n",(0,n.jsx)(t.a,{href:"https://www.youtube.com/watch?v=_T6KHywSP58",children:"QUEEN Video Explanation"})]}),"\n",(0,n.jsx)(t.p,{children:"This code relies on the speed at which sensors update, because it figures out the change in position over the time it takes for sensors to update, and adds that change to a current global value."}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"LEFT_OFFSET"})," and ",(0,n.jsx)(t.code,{children:"RIGHT_OFFSET"}),' are the "track width".  This is the width between the tracking wheels on the robot,  I have them split into 2 variables because technically they do not need to be the same number.',(0,n.jsx)(t.br,{}),"\n",(0,n.jsx)(t.code,{children:"CENTER_OFFSET"})," is the distance from a perpendicular tracking wheel to the turning center of the robot.  This number can actually be anything, but the nicest way is for this to align with the robot's turning center.  This can be tuned by turning the robot in place and adjusting this number until the XY stops rotating around the robot."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"void tracking_task() {\r\n  double l_current = 0, r_current = 0;\r\n  double c_current = 0;\r\n  double l = 0, r = 0, c = 0;  // delta distance\r\n  double l_last = 0, r_last = 0, c_last = 0;\r\n  double radius_r = 0, radius_c = 0, h = 0, h2 = 0;  // rad for big circle\r\n  double beta = 0, alpha = 0, theta = 0;\r\n  double Xx = 0, Yy = 0, Xy = 0, Yx = 0;\r\n  while (true) {\r\n    l_current = get_raw_left();\r\n    r_current = get_raw_right();\r\n    c_current = get_raw_center();\r\n\r\n    l = l_current - l_last;\r\n    r = r_current - r_last;\r\n    c = c_current - c_last;\r\n\r\n    l_last = l_current;\r\n    r_last = r_current;\r\n    c_last = c_current;\r\n\r\n    double width = LEFT_OFFSET + RIGHT_OFFSET;\r\n\r\n    // diff between wheels for correcting turning\r\n    theta = (l - r) / width;\r\n\r\n    if (theta != 0) {\r\n      radius_r = r / theta;\r\n      beta = theta / 2.0;\r\n      h = ((radius_r + RIGHT_OFFSET) * sin(beta)) * 2.0;\r\n      radius_c = c / theta;\r\n      h2 = (radius_c + CENTER_OFFSET) * 2.0 * sin(beta);\r\n    } else {\r\n      h = l;\r\n      h2 = 0;\r\n      beta = 0;\r\n    }\r\n\r\n    alpha = angle_rad + beta;\r\n\r\n    Xx = h2 * cos(alpha);\r\n    Xy = h2 * -sin(alpha);\r\n    Yx = h * sin(alpha);\r\n    Yy = h * cos(alpha);\r\n\r\n    current.x += (Xx + Yx) / TICK_PER_INCH;\r\n    current.y += (Xy + Yy) / TICK_PER_INCH;\r\n    angle_rad += theta;\r\n    current.theta = to_deg(angle_rad);\r\n\r\n    pros::delay(1);\r\n  }\r\n}\n"})}),"\n",(0,n.jsx)(t.h2,{id:"mecanum-drive",children:"Mecanum Drive"}),"\n",(0,n.jsxs)(t.p,{children:["Mecanum wheels allow the robot to move forward / backward and side to side.  These wheels get their own section here because they are effectively a cheat code for getting this code to work.  Because they can strafe, any error that's accumulated along the way can be accounted for.  With a drivetrain that cannot strafe, if you aren't following the path as exactly as you can, it becomes extremely difficult to account for it later.  This is why I chose this drive first, it allows me to go through all of this code without the problems that a typical drivetrain would give me.\r\n",(0,n.jsx)(t.img,{src:r(5956).Z+"",width:"1405",height:"812"})]}),"\n",(0,n.jsx)(t.h3,{id:"point-to-point",children:"Point to Point"}),"\n",(0,n.jsx)(t.p,{children:"To get the robot to move to a new target point, I need to calculate the amount the robot needs to move in the X direction, the amount the robot needs to move in the Y direction, and the amount the robot needs to move in turn."}),"\n",(0,n.jsx)(t.p,{children:"The direction the robot moves will change depending on the desired end angle. Some trigonometry is done to figure out the relative directions the robot needs to go, as while the robot turns the motor powers will all change."}),"\n",(0,n.jsx)(t.p,{children:"The final thing to do is scale everything down.  If X output and Y output both exceed the maximum power that can be sent to the motors, even if one is magnitudes larger than the other, the robot will end up going straight.  We solve this by scaling everything down to a larger number."}),"\n",(0,n.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/ZbMDKJ0zA3o?si=T7nrteA03m6vQWDE",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"void point_to_point() {\r\n  // Compute PID\r\n  xPID.compute(current.x);\r\n  yPID.compute(current.y);\r\n  aPID.compute(get_angle());\r\n\r\n  // Vector math\r\n  double angle = to_rad(get_angle());\r\n  double raw_x_power = (xPID.output * cos(angle)) - (yPID.output * sin(angle));\r\n  double raw_y_power = (yPID.output * cos(angle)) + (xPID.output * sin(angle));\r\n  double raw_a_power = aPID.output;\r\n\r\n  // Set output powers\r\n  int x_output = raw_x_power;\r\n  int y_output = raw_y_power;\r\n  int a_output = clip_num(raw_a_power, 60, -60);\r\n  int max_xy = 110;\r\n\r\n  // Vector scaling \r\n  if (fabs(raw_x_power) > max_xy || fabs(raw_y_power) > max_xy) {\r\n    if (fabs(raw_x_power) > fabs(raw_y_power)) {\r\n      double scale = max_xy / fabs(raw_x_power);\r\n      x_output = clip_num(raw_x_power, max_xy, -max_xy);\r\n      y_output = raw_y_power * scale;\r\n    } else {\r\n      double scale = max_xy / fabs(raw_y_power);\r\n      x_output = raw_x_power * scale;\r\n      y_output = clip_num(raw_y_power, max_xy, -max_xy);\r\n    }\r\n  } else {\r\n    x_output = raw_x_power;\r\n    y_output = raw_y_power;\r\n  }\r\n\r\n  // Set motors\r\n  raw_set_drive(x_output, y_output, a_output);\r\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"Mecanum drives that use the VRC wheels are slower when strafing than in forward / backward.  Because of this, I knew I'd want a mode where the robot would go straight for most of the motion and then turn at the end to face the desired angle."}),"\n",(0,n.jsx)(t.p,{children:"This piece of code was added to the above function.  It modifies the target angle depending on how far away the robot is from the target position.  If it's more than 12\" away, the robot will go faster and face the target position.  Once the robot is within 12\" of the target it'll start to rotate to the desired angle."}),"\n",(0,n.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/pIiadWcYlac?si=JW_q3pCaxF9RjtR2",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"  // Add for direction\r\n  int add = dir == REV ? 180 : 0;\r\n\r\n  // Set angle target\r\n  double a_target;\r\n  if (fast_move) {\r\n    if (fabs(distance_to_point(target.x, target.y)) < 12) {\r\n      only_look_at_point = false;\r\n      a_target = target.theta;\r\n    } else {\r\n      only_look_at_point = true;\r\n    }\r\n  } else {\r\n    a_target = target.theta;\r\n  }\r\n\r\n  if (only_look_at_point) {\r\n    a_target = absolute_angle_to_point(target.x, target.y) + add;\r\n  }\r\n\r\n  // Compute angle PID and find the shortest path to the angle\r\n  aPID.set_target(relative_angle_to_point(a_target));\r\n  aPID.compute(0);\n"})}),"\n",(0,n.jsx)(t.h3,{id:"paths-with-strafe",children:"Paths with Strafe"}),"\n",(0,n.jsx)(t.p,{children:"The paths the robot will follow will be points the user inputs.  In the example below, the robot will start at (0, 0), travel to (0, 24), then to (24, 24), then back to (0, 0)."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"void autonomous() {\r\n  pure_pursuit(\r\n        {{{0, 24, 0}, FAST_MOVE_FWD},\r\n         {{24, 24, 0}, FAST_MOVE_FWD},\r\n         {{0, 0, 0}, FAST_MOVE_REV}});\r\n  wait_drive();\r\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"Once I have a list of points, to decide which point to go to next I see how far away the robot is from the next point.  The target position gets shifted until we're looking at a point that is a distance away from the robot, and it keeps changing until we're at the final position in the list."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"void pure_pursuit() {\r\n  raw_move_odom(movements[pp_index]);\r\n\r\n  if (fabs(distance_to_point(movements[pp_index].target.x, movements[pp_index].target.y)) < 5) {\r\n    pp_index++;\r\n    if (pp_index >= movements.size()) {\r\n      pp_index = movements.size() - 1;\r\n    }\r\n  }\r\n\r\n  point_to_point();\r\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:['I cleaned up how the "turn type" is handled.  There are now 3 turn types:',(0,n.jsx)(t.br,{}),"\n",(0,n.jsx)(t.code,{children:"FAST_MOVE"}),' where the robot faces the target position and within 12" will move to the final angle\r\n',(0,n.jsx)(t.code,{children:"LOOK_AT_TARGET"})," where the robot doesn't care about the end angle, and will always look at the target\r\n",(0,n.jsx)(t.code,{children:"HOLD_ANGLE"})," where the robot will just hold its angle"]}),"\n",(0,n.jsxs)(t.p,{children:["I had to add ",(0,n.jsx)(t.code,{children:"LOOK_AT_TARGET"})," because the distance away from the current target was less than 12\", and the robot would always hold an angle even if I didn't want it to.  This lets me use ",(0,n.jsx)(t.code,{children:"FAST_MOVE"})," as intended, and have all of my injected points follow ",(0,n.jsx)(t.code,{children:"LOOK_AT_TARGET"}),"."]}),"\n",(0,n.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/aUpCYLBIhE0?si=LELL8e9J1XWCjrY3",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"  // Add for direction\r\n  int add = current_turn_type == FAST_MOVE_REV || LOOK_AT_TARGET_REV ? 180 : 0;\r\n\r\n  // Set angle target\r\n  switch (current_turn_type) {\r\n    // Looks at the target until final distance then goes to the final angle\r\n    case FAST_MOVE_FWD:\r\n    case FAST_MOVE_REV:\r\n      if (fabs(distance_to_point(target, current)) < TURN_FAST_MOVE) {\r\n        a_target = target.theta;\r\n      } else {\r\n        a_target = absolute_angle_to_point(target, current) + add;\r\n      }\r\n      break;\r\n    // Looks at target the entire motion\r\n    case LOOK_AT_TARGET_FWD:\r\n    case LOOK_AT_TARGET_REV:\r\n      if (fabs(distance_to_point(target, current)) > STOP_UPDATING_ANGLE) {\r\n        a_target = absolute_angle_to_point(target, current) + add;\r\n      }\r\n      break;\r\n    // Holds angle the entire motion\r\n    case HOLD_ANGLE:\r\n      a_target = target.theta;\r\n    default:\r\n      break;\r\n  }\n"})}),"\n",(0,n.jsx)(t.h3,{id:"final-mecanum",children:"Final Mecanum"}),"\n",(0,n.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/pVcdgffsMnA?si=P3Cc8XRpN6KGd6hI",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,n.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/A_Q_yBHhWSY?si=9qDZo20ImXHNNA5K",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,n.jsx)(t.h2,{id:"tank-drive",children:"Tank Drive"}),"\n",(0,n.jsxs)(t.p,{children:["Now the goal is to get this all working properly on a tank drive setup.  I have a kind of working version ",(0,n.jsx)(t.a,{href:"https://github.com/EZ-Robotics/peewee",children:"here"})," but I didn't have a lot of time with that robot to really iron everything out.  More will be coming soon."]})]})}function d(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},6655:(e,t,r)=>{r.d(t,{Z:()=>n});const n="data:image/png;base64,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"},5956:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/mecan_cad-7d3c32c0f976116b22930481f9921207.png"},1151:(e,t,r)=>{r.d(t,{Z:()=>s,a:()=>i});var n=r(7294);const a={},o=n.createContext(a);function i(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);